# Section 5: Operating System — Software We Take for Granted

**Duration:** 3 weeks  
**Prerequisites:** Section 4 (C compiler, libc, ethernet)  
**Languages:** SystemVerilog (MMU, SD card), C (kernel, filesystem, userspace)

---

## 5.1 Overview

This section builds a Unix-like operating system:

1. **MMU** (SystemVerilog, ~1000 lines) — Memory Management Unit with TLBs
2. **Kernel** (C, ~2500 lines) — Process management, memory, syscalls
3. **SD Card Controller** (SystemVerilog, ~150 lines) — Storage hardware
4. **FAT Filesystem** (C, ~300 lines) — Read/write files
5. **User Programs** (C, ~250 lines) — Shell and utilities

---

## 5.2 Project 1: Memory Management Unit

**Estimated Lines:** ~1000 SystemVerilog

### 5.2.1 Virtual Memory Concepts

```
VIRTUAL MEMORY OVERVIEW
=======================

Without MMU:
  - Physical addresses used directly
  - One program can corrupt another
  - No memory protection

With MMU:
  - Virtual addresses translated to physical
  - Each process has isolated address space
  - Memory protection enforced in hardware


ADDRESS TRANSLATION
===================

Virtual Address (32-bit):
┌────────────────┬────────────────┬──────────────┐
│   VPN[1]       │   VPN[0]       │   Offset     │
│   (10 bits)    │   (10 bits)    │  (12 bits)   │
└────────────────┴────────────────┴──────────────┘

Two-level page table (Sv32):
  - 4KB pages
  - 10-bit first level index (1024 entries)
  - 10-bit second level index (1024 entries)
  - 12-bit page offset

Translation process:
1. Use VPN[1] to index into root page table
2. Get physical address of second-level table
3. Use VPN[0] to index into second-level table
4. Get physical page number (PPN)
5. Concatenate PPN with offset


PAGE TABLE ENTRY (PTE) FORMAT (RISC-V Sv32)
==========================================

┌──────────────────────┬─┬─┬─┬─┬─┬─┬─┬─┐
│        PPN           │D│A│G│U│X│W│R│V│
│      (22 bits)       │1│1│1│1│1│1│1│1│
└──────────────────────┴─┴─┴─┴─┴─┴─┴─┴─┘

V: Valid
R: Readable
W: Writable
X: Executable
U: User-mode accessible
G: Global (not flushed on ASID change)
A: Accessed (hardware sets on access)
D: Dirty (hardware sets on write)

If R=0, W=0, X=0: PTE is pointer to next level
Otherwise: PTE is leaf (actual mapping)
```

### 5.2.2 TLB (Translation Lookaside Buffer)

```
TLB STRUCTURE
=============

TLB is a cache of recent translations:

┌─────────────────────────────────────────────────────────────┐
│                          TLB                                │
│                                                             │
│  Entry 0: │ Valid │ VPN │ ASID │ PPN │ Permissions │        │
│  Entry 1: │ Valid │ VPN │ ASID │ PPN │ Permissions │        │
│    ...                                                      │
│  Entry N: │ Valid │ VPN │ ASID │ PPN │ Permissions │        │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Lookup:
1. Compare VPN against all entries (fully associative)
2. Also compare ASID (Address Space ID) for process isolation
3. On hit: return PPN + permissions
4. On miss: walk page table, insert result

ASID allows multiple processes' mappings to coexist in TLB


MMU BLOCK DIAGRAM
=================

                     ┌────────────────────────────────────────────────┐
                     │                     MMU                        │
                     │                                                │
   Virtual      ────▶│  ┌─────────────────────────────────────────┐   │
   Address           │  │                  TLB                    │   │
                     │  │                                         │   │
                     │  │   ┌─────────────────────────────────┐   │   │
                     │  │   │ Fully Associative Lookup        │   │   │
                     │  │   │ (compare VPN, ASID in parallel) │   │   │
                     │  │   └────────────┬────────────────────┘   │   │
                     │  │                │                        │   │
                     │  │     ┌──────────┴──────────┐             │   │
                     │  │     │ Hit?                │             │   │
                     │  │     └──────────┬──────────┘             │   │
                     │  │        Yes │        │ No                │   │
                     │  └────────────┼────────┼───────────────────┘   │
                     │               │        │                       │
                     │               │        ▼                       │
                     │               │  ┌─────────────────────────┐   │
                     │               │  │    Page Table Walker    │   │
                     │               │  │                         │   │
                     │               │  │ 1. Read L1 PTE          │   │
                     │               │  │ 2. Read L2 PTE          │   │
                     │               │  │ 3. Insert into TLB      │   │
                     │               │  └────────────┬────────────┘   │
                     │               │               │                │
                     │               ▼               ▼                │
                     │         ┌─────────────────────────┐            │
                     │         │   Permission Check      │            │
                     │         │   (R/W/X vs access type)│            │
                     │         └────────────┬────────────┘            │
                     │                      │                         │
                     │           ┌──────────┴──────────┐              │
                     │           │ Pass?               │              │
                     │           └──────────┬──────────┘              │
                     │              Yes │        │ No                 │
                     │                  ▼        ▼                    │
   Physical     ◀────│────────────  PPN+Offset   Page Fault           │
   Address           │                          Exception             │
                     │                                                │
                     └────────────────────────────────────────────────┘
```

### 5.2.3 Implementation Checklist

#### File: `rtl/core/mmu.sv`

- [ ] **Module ports**
  - Virtual address input
  - Physical address output
  - Access type (read/write/execute)
  - Privilege mode (user/supervisor)
  - SATP register value (page table base + ASID)
  - Enable/disable
  - Memory interface for page table walks
  - Page fault exception output

- [ ] **SATP register interface**
  ```systemverilog
  // SATP format (Sv32)
  // [31]: MODE (0=bare, 1=Sv32)
  // [30:22]: ASID (9 bits)
  // [21:0]: PPN of root page table
  ```

- [ ] **Control logic**
  - Bypass when MODE=0 (bare)
  - Different handling for supervisor vs user

#### File: `rtl/core/tlb.sv`

- [ ] **TLB parameters**
  - Number of entries (e.g., 16-64)
  - Fully associative organization

- [ ] **TLB entry structure**
  ```systemverilog
  typedef struct packed {
      logic valid;
      logic [19:0] vpn;        // Virtual page number
      logic [8:0] asid;        // Address space ID
      logic [21:0] ppn;        // Physical page number
      logic readable;
      logic writable;
      logic executable;
      logic user;
      logic global;
      logic dirty;
      logic accessed;
  } tlb_entry_t;
  ```

- [ ] **Lookup logic**
  - Compare VPN and ASID against all entries
  - Priority encoder for multiple matches (shouldn't happen)
  - Output hit/miss and entry data

- [ ] **Replacement policy**
  - Simple: round-robin
  - Better: pseudo-LRU

- [ ] **TLB operations**
  - Insert entry (on page table walk complete)
  - Invalidate single entry (SFENCE.VMA with address)
  - Invalidate by ASID (SFENCE.VMA with ASID)
  - Invalidate all (SFENCE.VMA)

#### File: `rtl/core/ptw.sv` (Page Table Walker)

- [ ] **Walker state machine**
  ```
  IDLE → L1_READ → L1_WAIT → L2_READ → L2_WAIT → DONE/FAULT
  ```

- [ ] **State: L1_READ**
  - Calculate L1 PTE address: (SATP.PPN << 12) + (VPN[1] << 2)
  - Issue memory read

- [ ] **State: L1_WAIT**
  - Wait for memory response
  - Check PTE valid bit
  - If invalid: page fault
  - If leaf (R|W|X != 0): superpage, done
  - If pointer: proceed to L2

- [ ] **State: L2_READ**
  - Calculate L2 PTE address: (L1_PTE.PPN << 12) + (VPN[0] << 2)
  - Issue memory read

- [ ] **State: L2_WAIT**
  - Wait for memory response
  - Check PTE valid bit
  - If invalid: page fault
  - Extract PPN and permissions

- [ ] **Permission checking**
  - User mode accessing U=0 page: fault
  - Write to R=1, W=0 page: fault
  - Execute from X=0 page: fault

- [ ] **A/D bit handling**
  - If A=0 and accessing: set A=1 (write back PTE)
  - If D=0 and writing: set D=1 (write back PTE)
  - Or: take page fault, let software handle

#### File: `rtl/core/mmu_integration.sv`

- [ ] **Core integration**
  - Insert MMU between CPU and memory bus
  - Separate instruction and data paths (or unified)

- [ ] **CSR interface**
  - SATP register read/write
  - SFENCE.VMA instruction handling

- [ ] **Exception generation**
  - Instruction page fault
  - Load page fault
  - Store page fault
  - With faulting address in STVAL

#### File: `rtl/core/pkg_mmu.sv`

- [ ] **Constants**
  - Page size (4096)
  - VPN width, PPN width
  - Exception codes

- [ ] **Type definitions**
  - PTE type
  - TLB entry type
  - Walker state type

#### File: `tb/test_mmu.py`

- [ ] **Test: identity_mapping**
  - Create page table mapping VA=PA
  - Access memory, verify translation

- [ ] **Test: offset_mapping**
  - Map VA 0x1000_0000 → PA 0x2000_0000
  - Verify correct physical access

- [ ] **Test: permission_fault**
  - Map page as read-only
  - Attempt write
  - Verify page fault

- [ ] **Test: user_supervisor**
  - Map page with U=0
  - Access from user mode
  - Verify page fault

- [ ] **Test: tlb_miss**
  - Access page not in TLB
  - Verify page table walk
  - Verify TLB filled

- [ ] **Test: tlb_invalidate**
  - Fill TLB with mappings
  - SFENCE.VMA
  - Verify TLB cleared

- [ ] **Test: asid_isolation**
  - Two processes with same VA, different PA
  - Switch ASID
  - Verify correct translation

- [ ] **Test: superpage**
  - Map 4MB superpage (L1 leaf)
  - Verify translation

---

## 5.3 Project 2: Operating System Kernel

**Estimated Lines:** ~2500 C

### 5.3.1 Kernel Architecture

```
KERNEL ARCHITECTURE
===================

┌─────────────────────────────────────────────────────────────────────┐
│                           USER SPACE                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│  │  shell   │  │   cat    │  │    ls    │  │  app...  │            │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘            │
│       │             │             │             │                   │
└───────┼─────────────┼─────────────┼─────────────┼───────────────────┘
        │             │             │             │
        └─────────────┴──────┬──────┴─────────────┘
                             │ syscall (ecall)
┌────────────────────────────┼────────────────────────────────────────┐
│                            ▼                                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    SYSTEM CALL INTERFACE                     │   │
│  │  open, read, write, close, fork, exec, wait, exit, mmap...  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                            │                                        │
│  ┌─────────────────────────┼─────────────────────────────────────┐ │
│  │                         ▼                                     │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │ │
│  │  │   Process   │  │   Virtual   │  │    File     │           │ │
│  │  │   Manager   │  │   Memory    │  │   System    │           │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘           │ │
│  │                                                               │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │ │
│  │  │  Scheduler  │  │    Page     │  │   Device    │           │ │
│  │  │             │  │   Allocator │  │   Drivers   │           │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘           │ │
│  │                     KERNEL CORE                               │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                                                                     │
│                         KERNEL SPACE                                │
└─────────────────────────────────────────────────────────────────────┘

MEMORY MAP WITH OS
==================

0x0000_0000 - 0x7FFF_FFFF: User space (2GB)
  Per-process:
  0x0000_1000 - 0x0040_0000: Code (.text)
  0x0040_0000 - 0x0080_0000: Data (.data, .bss)
  0x0080_0000 - ...........: Heap (grows up)
  0x7FFF_0000 - 0x7FFF_FFFF: Stack (grows down)

0x8000_0000 - 0xFFFF_FFFF: Kernel space (2GB)
  0x8000_0000 - 0x8010_0000: Kernel code/data (1MB)
  0x8010_0000 - 0x8100_0000: Kernel heap (15MB)
  0x8100_0000 - 0x9000_0000: Direct-mapped physical memory
  0xF000_0000 - 0xF000_0FFF: UART (MMIO)
  0xF000_1000 - 0xF000_1FFF: Ethernet (MMIO)
  0xF000_2000 - 0xF000_2FFF: SD Card (MMIO)
```

### 5.3.2 System Calls

```
SYSTEM CALL LIST
================

File Operations:
  SYS_open    (path, flags, mode) → fd
  SYS_read    (fd, buf, count) → bytes_read
  SYS_write   (fd, buf, count) → bytes_written
  SYS_close   (fd) → status
  SYS_lseek   (fd, offset, whence) → position

Process Operations:
  SYS_fork    () → pid (0 in child, child_pid in parent)
  SYS_execve  (path, argv, envp) → doesn't return on success
  SYS_wait    (status_ptr) → pid of terminated child
  SYS_exit    (status) → doesn't return
  SYS_getpid  () → pid
  SYS_sleep   (seconds) → 0

Memory Operations:
  SYS_mmap    (addr, length, prot, flags, fd, offset) → addr
  SYS_munmap  (addr, length) → status
  SYS_mprotect(addr, length, prot) → status
  SYS_brk     (addr) → new_brk


SYSCALL CONVENTION (RISC-V)
===========================

Syscall number: a7
Arguments: a0, a1, a2, a3, a4, a5
Return value: a0
Invoke: ecall instruction

Kernel preserves all registers except a0 (return value)
```

### 5.3.3 Implementation Checklist

#### File: `sw/kernel/main.c`

- [ ] **kernel_main()**
  - Initialize console (UART)
  - Print banner
  - Initialize memory manager
  - Initialize process manager
  - Initialize filesystem
  - Initialize drivers
  - Create init process
  - Start scheduler (never returns)

#### File: `sw/kernel/boot.s`

- [ ] **_start entry point**
  - Set up kernel stack
  - Clear BSS
  - Call kernel_main

- [ ] **Trap vector setup**
  - Set STVEC to trap handler
  - Configure delegation (MEDELEG, MIDELEG)

#### File: `sw/kernel/trap.c`

- [ ] **Trap handler entry (assembly)**
  - Save all registers to stack
  - Call C trap handler
  - Restore registers
  - SRET

- [ ] **trap_handler()**
  - Read SCAUSE
  - Dispatch based on cause:
    - Syscall (cause = 8)
    - Page fault (cause = 12, 13, 15)
    - Timer interrupt
    - External interrupt

- [ ] **Syscall dispatch**
  - Read syscall number from a7
  - Read arguments from a0-a5
  - Call appropriate handler
  - Return value in a0

#### File: `sw/kernel/syscall.c`

- [ ] **sys_open()**
  - Resolve path
  - Find/create file descriptor
  - Call filesystem open

- [ ] **sys_read()**
  - Validate fd
  - Check buffer permissions
  - Call filesystem read

- [ ] **sys_write()**
  - Validate fd
  - Check buffer permissions
  - Call filesystem write
  - Special case: stdout/stderr → console

- [ ] **sys_close()**
  - Validate fd
  - Release file descriptor

- [ ] **sys_fork()**
  - Allocate new PCB
  - Copy parent's address space (COW optional)
  - Copy file descriptors
  - Set up child's registers (a0 = 0)
  - Add to scheduler

- [ ] **sys_execve()**
  - Load ELF file
  - Set up new address space
  - Parse argv, envp
  - Set up user stack
  - Don't return (jump to entry)

- [ ] **sys_wait()**
  - Find zombie child
  - If none, block
  - Collect exit status
  - Free child resources

- [ ] **sys_exit()**
  - Set process state to zombie
  - Store exit status
  - Release resources
  - Wake parent if waiting
  - Schedule other process

- [ ] **sys_getpid()**
  - Return current process ID

- [ ] **sys_sleep()**
  - Calculate wake time
  - Block process
  - Schedule other process

- [ ] **sys_brk()**
  - Adjust heap end
  - Allocate pages if growing
  - Return new break

- [ ] **sys_mmap()**
  - Find free virtual address range
  - Create mapping (on-demand or immediate)
  - If file-backed: set up file reference

- [ ] **sys_munmap()**
  - Remove page table entries
  - Free physical pages

#### File: `sw/kernel/proc.c`

- [ ] **Process Control Block (PCB)**
  ```c
  struct pcb {
      int pid;
      int ppid;                    // parent PID
      enum proc_state state;       // RUNNING, READY, BLOCKED, ZOMBIE
      uint32_t *page_table;        // root page table
      struct trap_frame *tf;       // saved registers
      uint32_t kernel_sp;          // kernel stack pointer
      struct file *files[16];      // open file descriptors
      uint32_t brk;                // program break (heap end)
      int exit_status;
      struct pcb *parent;
      struct list_head children;
      struct list_head siblings;
  };
  ```

- [ ] **proc_init()**
  - Initialize process table
  - Create process 0 (kernel idle)

- [ ] **proc_alloc()**
  - Allocate PCB from pool
  - Assign unique PID
  - Allocate kernel stack

- [ ] **proc_free()**
  - Free PCB
  - Free kernel stack
  - Free page table

- [ ] **proc_create()**
  - Allocate PCB
  - Set up initial state
  - Add to scheduler

#### File: `sw/kernel/sched.c`

- [ ] **Scheduler data structures**
  - Run queue (ready processes)
  - Current process pointer

- [ ] **sched_init()**
  - Initialize run queue

- [ ] **sched_add()**
  - Add process to run queue

- [ ] **sched_remove()**
  - Remove process from run queue

- [ ] **schedule()**
  - Select next process (round-robin)
  - If same process, return
  - Context switch to selected process

- [ ] **context_switch()**
  - Save current process registers
  - Switch page tables (SATP)
  - SFENCE.VMA
  - Restore next process registers
  - Return to next process

- [ ] **Timer interrupt handler**
  - Increment tick count
  - Wake sleeping processes
  - Maybe preempt (call schedule)

#### File: `sw/kernel/vm.c`

- [ ] **Page allocator**
  - Physical page frame tracking
  - Bitmap or free list

- [ ] **page_alloc()**
  - Find free physical page
  - Mark as used
  - Return physical address

- [ ] **page_free()**
  - Mark page as free
  - Add to free list

- [ ] **Page table management**
  - Create page table
  - Destroy page table
  - Map page
  - Unmap page

- [ ] **pt_create()**
  - Allocate root page table
  - Copy kernel mappings

- [ ] **pt_destroy()**
  - Walk table, free all pages
  - Free page table pages

- [ ] **pt_map()**
  - Walk to correct PTE (allocate intermediate tables)
  - Set PTE with PPN and permissions

- [ ] **pt_unmap()**
  - Clear PTE
  - Optionally free physical page

- [ ] **Page fault handler**
  - Determine fault type (read/write/exec)
  - Check if valid mapping exists
  - Allocate page if demand-paged
  - Or: kill process if invalid access

- [ ] **Address space operations**
  - as_create(): new empty address space
  - as_copy(): fork copy (optionally COW)
  - as_destroy(): free entire address space

#### File: `sw/kernel/console.c`

- [ ] **console_init()**
  - Initialize UART

- [ ] **console_putchar()**
  - Write character to UART

- [ ] **console_getchar()**
  - Read character from UART (blocking)

- [ ] **console_write()**
  - Write buffer to console

- [ ] **kprintf()**
  - Kernel printf (like libc but kernel-space)

#### File: `sw/kernel/fs.c`

- [ ] **Filesystem interface**
  ```c
  struct file_operations {
      int (*open)(struct file *, const char *path, int flags);
      int (*close)(struct file *);
      int (*read)(struct file *, void *buf, size_t count);
      int (*write)(struct file *, const void *buf, size_t count);
      off_t (*lseek)(struct file *, off_t offset, int whence);
  };
  ```

- [ ] **File descriptor table**
  - Per-process array of open files
  - Reference counting for shared files (fork)

- [ ] **vfs_open()**
  - Parse path
  - Find filesystem
  - Call fs-specific open

- [ ] **vfs_read/write/close()**
  - Dispatch to appropriate driver

- [ ] **Special files**
  - /dev/console → UART
  - /dev/null → discard writes, EOF on read
  - /dev/zero → endless zeros on read

#### File: `sw/kernel/elf.c`

- [ ] **ELF loader**
  - Parse ELF header
  - Validate it's RISC-V executable

- [ ] **load_elf()**
  - Read program headers
  - For each PT_LOAD segment:
    - Allocate virtual memory
    - Read segment data
    - Set permissions
  - Return entry point

- [ ] **setup_user_stack()**
  - Allocate stack pages
  - Copy argv, envp to stack
  - Set up initial stack frame

#### File: `sw/kernel/include/kernel.h`

- [ ] **Type definitions**
  - pid_t, off_t, size_t
  - Register width types

- [ ] **PCB declaration**
- [ ] **Global variables**
  - current (current process)
  - process_table

- [ ] **Function prototypes**
  - All kernel functions

#### File: `sw/kernel/linker.ld`

- [ ] **Kernel memory layout**
  - .text at 0x80000000
  - .rodata, .data, .bss
  - Stack at known location

- [ ] **Symbols for BSS clearing**
  - __bss_start, __bss_end

- [ ] **Symbols for page allocator**
  - __kernel_end (start of free memory)

#### File: `sw/kernel/Makefile`

- [ ] **Compile kernel C files**
- [ ] **Assemble boot.s**
- [ ] **Link into kernel.elf**
- [ ] **Create kernel.bin for loading**

#### Tests: `tb/test_kernel.py`

- [ ] **Test: boot_to_shell**
  - Load kernel
  - Verify init process starts
  - Verify shell prompt

- [ ] **Test: syscall_write**
  - User program calls write()
  - Verify output appears

- [ ] **Test: fork_basic**
  - Fork and verify both processes run

- [ ] **Test: exec_basic**
  - Exec new program
  - Verify it runs

- [ ] **Test: page_fault_handling**
  - Access unmapped memory
  - Verify process killed (or page allocated)

---

## 5.4 Project 3: SD Card Controller

**Estimated Lines:** ~150 SystemVerilog

### 5.4.1 SD Card Protocol

```
SD CARD SPI MODE
================

For simplicity, use SPI mode (not native SD mode):

Signals:
  SCLK  - Serial clock (output)
  MOSI  - Master Out Slave In (output)
  MISO  - Master In Slave Out (input)
  CS    - Chip Select (output, active low)

Commands (selected):
  CMD0  - GO_IDLE_STATE (reset)
  CMD8  - SEND_IF_COND (voltage check)
  CMD17 - READ_SINGLE_BLOCK
  CMD24 - WRITE_SINGLE_BLOCK
  CMD55 - APP_CMD (prefix for ACMD)
  ACMD41- SD_SEND_OP_COND (initialize)

Command format (48 bits):
  [47:46] Start bits (01)
  [45:40] Command index
  [39:8]  Argument
  [7:1]   CRC7
  [0]     Stop bit (1)

Response R1 (8 bits):
  [7] Always 0
  [6] Parameter error
  [5] Address error
  [4] Erase sequence error
  [3] CRC error
  [2] Illegal command
  [1] Erase reset
  [0] Idle state


SD CARD BLOCK DIAGRAM
=====================

┌──────────────────────────────────────────────────────────────┐
│                        sd_controller                          │
│                                                              │
│  MMIO Interface                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  0x00: CMD (write: issue command)                      │ │
│  │  0x04: ARG (write: command argument)                   │ │
│  │  0x08: RESP (read: response)                           │ │
│  │  0x0C: STATUS (read: busy, error flags)                │ │
│  │  0x10: DATA (read/write: 512-byte block buffer)        │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
│  ┌──────────────────┐                                       │
│  │   SPI Master     │                                       │
│  │                  │                                       │
│  │ ┌──────────────┐ │                                       │
│  │ │ Shift Reg    │ │                                       │
│  │ └──────────────┘ │                                       │
│  │ ┌──────────────┐ │                                       │
│  │ │ Clock Gen    │ │                                       │
│  │ └──────────────┘ │                                       │
│  └────────┬─────────┘                                       │
│           │                                                  │
└───────────┼──────────────────────────────────────────────────┘
            │
            ▼
    SCLK, MOSI, MISO, CS (to SD card)
```

### 5.4.2 Implementation Checklist

#### File: `rtl/peripherals/sd_controller.sv`

- [ ] **Module ports**
  - Clock, reset
  - MMIO interface
  - SPI signals: sclk, mosi, miso, cs_n

- [ ] **SPI clock generation**
  - Divide system clock to SPI clock (≤25MHz for SD)
  - Configurable divider

- [ ] **Shift register**
  - 8-bit shift for byte transfers
  - Shift on SPI clock edge
  - CPOL=0, CPHA=0 (SD card SPI mode)

- [ ] **Command state machine**
  ```
  IDLE → SEND_CMD → WAIT_RESP → READ_DATA/WRITE_DATA → DONE
  ```

- [ ] **Command transmission**
  - Assert CS low
  - Shift out 48-bit command
  - Wait for response (poll MISO for start bit)

- [ ] **Response reception**
  - R1: 8 bits
  - R3/R7: 40 bits

- [ ] **Block read**
  - After CMD17
  - Wait for data token (0xFE)
  - Receive 512 bytes
  - Receive 2-byte CRC

- [ ] **Block write**
  - After CMD24
  - Send data token (0xFE)
  - Send 512 bytes
  - Send 2-byte CRC (dummy OK)
  - Wait for response token

- [ ] **Block buffer**
  - 512-byte BRAM
  - CPU read/write access

#### File: `rtl/peripherals/spi_master.sv`

- [ ] **Reusable SPI master**
  - Configurable clock divider
  - 8-bit transfer interface
  - Directly usable by SD controller

#### File: `tb/test_sd_controller.py`

- [ ] **SD card model**
  - Respond to commands
  - Store block data
  - Simulate timing

- [ ] **Test: initialization**
  - CMD0, CMD8, ACMD41 sequence
  - Verify card ready

- [ ] **Test: read_block**
  - CMD17 read
  - Verify data received

- [ ] **Test: write_block**
  - CMD24 write
  - Verify data stored

---

## 5.5 Project 4: FAT Filesystem

**Estimated Lines:** ~300 C

### 5.5.1 FAT16 Structure

```
FAT16 DISK LAYOUT
=================

┌────────────────────────┐  Sector 0
│     Boot Sector        │  (512 bytes)
├────────────────────────┤
│     Reserved Sectors   │  (usually 1)
├────────────────────────┤  
│     FAT #1             │  File Allocation Table
├────────────────────────┤
│     FAT #2 (backup)    │  Copy of FAT
├────────────────────────┤
│   Root Directory       │  Fixed size (FAT16)
├────────────────────────┤
│                        │
│     Data Area          │  Actual file contents
│   (clusters)           │
│                        │
└────────────────────────┘


BOOT SECTOR (Important Fields)
==============================

Offset │ Size │ Description
───────┼──────┼────────────────────────
0x00   │  3   │ Jump instruction
0x03   │  8   │ OEM name
0x0B   │  2   │ Bytes per sector (512)
0x0D   │  1   │ Sectors per cluster
0x0E   │  2   │ Reserved sector count
0x10   │  1   │ Number of FATs (2)
0x11   │  2   │ Root entry count
0x13   │  2   │ Total sectors (16-bit)
0x16   │  2   │ Sectors per FAT


FAT ENTRY VALUES (16-bit)
=========================

0x0000        : Free cluster
0x0001        : Reserved
0x0002-0xFFEF : Next cluster in chain
0xFFF0-0xFFF6 : Reserved
0xFFF7        : Bad cluster
0xFFF8-0xFFFF : End of chain


DIRECTORY ENTRY (32 bytes)
==========================

Offset │ Size │ Description
───────┼──────┼────────────────────────
0x00   │ 11   │ Filename (8.3 format)
0x0B   │  1   │ Attributes
0x14   │  2   │ First cluster (high, FAT32)
0x16   │  2   │ Time
0x18   │  2   │ Date
0x1A   │  2   │ First cluster (low)
0x1C   │  4   │ File size

Attributes:
  0x01: Read-only
  0x02: Hidden
  0x04: System
  0x08: Volume label
  0x10: Directory
  0x20: Archive
```

### 5.5.2 Implementation Checklist

#### File: `sw/kernel/fat.c`

- [ ] **FAT16 structures**
  ```c
  struct fat_boot_sector {
      uint8_t jump[3];
      char oem[8];
      uint16_t bytes_per_sector;
      uint8_t sectors_per_cluster;
      uint16_t reserved_sectors;
      uint8_t num_fats;
      uint16_t root_entries;
      uint16_t total_sectors_16;
      uint8_t media_type;
      uint16_t fat_sectors;
      // ... more fields
  } __attribute__((packed));
  
  struct fat_dir_entry {
      char name[11];
      uint8_t attr;
      uint8_t reserved[10];
      uint16_t cluster;
      uint32_t size;
  } __attribute__((packed));
  ```

- [ ] **fat_mount()**
  - Read boot sector
  - Validate FAT signature
  - Calculate FAT start, root dir start, data start
  - Store in filesystem state

- [ ] **fat_read_sector()**
  - Wrapper around SD card block read

- [ ] **fat_write_sector()**
  - Wrapper around SD card block write

- [ ] **Cluster operations**
  - cluster_to_sector(): convert cluster to sector number
  - fat_get_next(): read FAT, get next cluster
  - fat_set_next(): write FAT entry
  - fat_alloc_cluster(): find and allocate free cluster

- [ ] **fat_open()**
  - Parse path (split by '/')
  - Search root directory (or subdirectory)
  - Find matching entry
  - Return file handle with cluster, size, position

- [ ] **fat_read()**
  - Calculate which cluster and offset
  - Read sectors
  - Follow cluster chain if needed
  - Copy to user buffer

- [ ] **fat_write()**
  - Calculate position
  - Allocate clusters if extending
  - Write sectors
  - Update FAT
  - Update directory entry (size)

- [ ] **fat_close()**
  - Flush any buffered writes
  - Release file handle

- [ ] **Directory operations**
  - fat_readdir(): enumerate directory entries
  - fat_mkdir(): create directory (optional)
  - fat_create(): create new file

- [ ] **8.3 filename handling**
  - Convert "filename.txt" to "FILENAME TXT"
  - Handle long filename entries (optional, complex)

#### File: `sw/kernel/sd_driver.c`

- [ ] **sd_init()**
  - Send initialization sequence
  - CMD0, CMD8, ACMD41
  - Wait for card ready

- [ ] **sd_read_block()**
  - CMD17 with block address
  - Read 512 bytes

- [ ] **sd_write_block()**
  - CMD24 with block address
  - Write 512 bytes

#### Tests: `sw/kernel/test/test_fat.c`

- [ ] **Test: mount**
  - Mount FAT filesystem
  - Verify parameters read correctly

- [ ] **Test: read_file**
  - Open existing file
  - Read contents
  - Verify correct

- [ ] **Test: write_file**
  - Create new file
  - Write data
  - Close and reopen
  - Verify data persisted

- [ ] **Test: directory_listing**
  - Read directory
  - Verify all entries found

---

## 5.6 Project 5: User Programs

**Estimated Lines:** ~250 C

### 5.6.1 Programs to Implement

```
USER PROGRAMS
=============

init  - First user process, launches shell
shell - Command interpreter
cat   - Print file contents
ls    - List directory
rm    - Remove file
echo  - Print arguments
```

### 5.6.2 Implementation Checklist

#### File: `sw/user/init.c`

- [ ] **main()**
  - Fork and exec shell
  - Wait for shell to exit
  - Restart shell (loop forever)
  - Handle orphan processes

```c
int main() {
    while (1) {
        int pid = fork();
        if (pid == 0) {
            // Child: exec shell
            char *argv[] = {"/bin/shell", NULL};
            execve("/bin/shell", argv, NULL);
            exit(1);  // exec failed
        } else {
            // Parent: wait for shell
            wait(NULL);
        }
    }
}
```

#### File: `sw/user/shell.c`

- [ ] **main()**
  - Print prompt
  - Read command line
  - Parse command
  - Execute command
  - Loop

- [ ] **read_line()**
  - Read characters until newline
  - Handle backspace
  - Return string

- [ ] **parse_command()**
  - Split line by spaces
  - Build argv array
  - Handle quotes (optional)

- [ ] **execute_command()**
  - Check for built-in commands (cd, exit)
  - Fork
  - Child: exec command
  - Parent: wait for child

- [ ] **Built-in commands**
  - cd: change directory (not in our minimal set)
  - exit: exit shell

- [ ] **Path resolution**
  - If command contains '/', use as-is
  - Otherwise, prepend "/bin/"

#### File: `sw/user/cat.c`

- [ ] **main(argc, argv)**
  - For each file argument:
  - Open file
  - Read and print contents
  - Close file

```c
int main(int argc, char *argv[]) {
    char buf[512];
    for (int i = 1; i < argc; i++) {
        int fd = open(argv[i], O_RDONLY);
        if (fd < 0) {
            printf("cat: %s: No such file\n", argv[i]);
            continue;
        }
        int n;
        while ((n = read(fd, buf, sizeof(buf))) > 0) {
            write(1, buf, n);
        }
        close(fd);
    }
    return 0;
}
```

#### File: `sw/user/ls.c`

- [ ] **main(argc, argv)**
  - If no args, list current directory
  - Otherwise, list each argument

- [ ] **list_directory()**
  - Open directory
  - Read entries
  - Print names

```c
int main(int argc, char *argv[]) {
    char *path = argc > 1 ? argv[1] : ".";
    int fd = open(path, O_RDONLY | O_DIRECTORY);
    if (fd < 0) {
        printf("ls: cannot open %s\n", path);
        return 1;
    }
    struct dirent de;
    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
        if (de.name[0] != '\0') {
            printf("%s\n", de.name);
        }
    }
    close(fd);
    return 0;
}
```

#### File: `sw/user/rm.c`

- [ ] **main(argc, argv)**
  - For each file argument:
  - Call unlink() syscall

```c
int main(int argc, char *argv[]) {
    for (int i = 1; i < argc; i++) {
        if (unlink(argv[i]) < 0) {
            printf("rm: cannot remove %s\n", argv[i]);
        }
    }
    return 0;
}
```

#### File: `sw/user/echo.c`

- [ ] **main(argc, argv)**
  - Print each argument with spaces
  - Print newline

```c
int main(int argc, char *argv[]) {
    for (int i = 1; i < argc; i++) {
        if (i > 1) putchar(' ');
        printf("%s", argv[i]);
    }
    putchar('\n');
    return 0;
}
```

#### File: `sw/user/libc_user.c` (User-space libc additions)

- [ ] **Syscall wrappers**
  ```c
  static inline int syscall(int num, int a0, int a1, int a2) {
      register int a7 asm("a7") = num;
      register int r0 asm("a0") = a0;
      register int r1 asm("a1") = a1;
      register int r2 asm("a2") = a2;
      asm volatile("ecall"
          : "+r"(r0)
          : "r"(a7), "r"(r1), "r"(r2)
          : "memory");
      return r0;
  }
  
  int open(const char *path, int flags) {
      return syscall(SYS_open, (int)path, flags, 0);
  }
  // ... etc
  ```

#### File: `sw/user/Makefile`

- [ ] **Compile each program**
- [ ] **Link with user libc**
- [ ] **Create filesystem image with programs**

---

## 5.7 Kernel Debug Interface

### 5.7.1 Options for Debugging

```
DEBUG OPTIONS
=============

1. kprintf() - Print to UART
   - Simple but limited
   - Good for development

2. QEMU + GDB
   - Connect GDB to QEMU
   - Full source-level debugging
   - Doesn't help with our simulator

3. Semihosting
   - Special instructions interpreted by host
   - printf routed to host console
   - File I/O to host filesystem

4. GDB Remote Stub
   - Implement GDB protocol in kernel
   - Connect GDB over serial
   - Step, breakpoint, inspect memory
   - Complex but powerful


GDB REMOTE PROTOCOL (simplified)
================================

Commands (text over serial):
  g         - Read all registers
  G<data>   - Write all registers
  m<addr>,<len>  - Read memory
  M<addr>,<len>:<data> - Write memory
  c         - Continue execution
  s         - Single step
  ?         - Query halt reason
  Z0,<addr>,<len> - Set breakpoint
  z0,<addr>,<len> - Remove breakpoint

Responses:
  OK        - Success
  E<nn>     - Error
  S<signal> - Stopped with signal
  T<signal>... - Stopped with details
```

### 5.7.2 Implementation Checklist (Optional GDB Stub)

#### File: `sw/kernel/gdb_stub.c`

- [ ] **gdb_init()**
  - Set up serial for GDB
  - Install breakpoint handler

- [ ] **gdb_trap_handler()**
  - Called on breakpoint/step
  - Enter GDB command loop

- [ ] **gdb_getpacket()**
  - Read packet from serial
  - Validate checksum

- [ ] **gdb_putpacket()**
  - Send packet with checksum

- [ ] **Command handlers**
  - handle_g(): send registers
  - handle_G(): receive registers
  - handle_m(): read memory
  - handle_M(): write memory
  - handle_c(): continue
  - handle_s(): single step

- [ ] **Breakpoint management**
  - Replace instruction with EBREAK
  - Restore on removal

---

## 5.8 Concepts to Internalize

Before proceeding to Section 6:

1. **Virtual memory isolation**: Each process has private address space
2. **Context switching**: Saving and restoring process state
3. **System calls**: Safe transition from user to kernel mode
4. **Page faults**: Hardware signals software to handle missing pages
5. **Filesystem abstraction**: Files as named byte sequences
6. **Process lifecycle**: fork/exec/wait/exit pattern

---

## 5.9 Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| TLB not flushed after page table change | Always SFENCE.VMA |
| Kernel corrupts user registers | Save all registers on trap entry |
| Page fault in page fault handler | Map kernel pages with supervisor access |
| File descriptor leak | Close files in exit() |
| Fork copies too little/much | Carefully specify what's shared vs copied |
| SD card timing issues | Respect init sequence, use delays |
| FAT cluster chains corrupted | Always update FAT atomically |
