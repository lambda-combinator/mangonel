# Section 4: Compiler — A "High" Level Language

**Duration:** 3 weeks  
**Prerequisites:** Section 3 (Working CPU + Assembler)  
**Languages:** Haskell (compiler), Python (linker), C (libc, bootloader), SystemVerilog (ethernet)

---

## 4.1 Overview

This section enables C programming on our system:

1. **C Compiler** (Haskell, ~2000 lines) — Compiles C to RISC-V assembly
2. **Linker** (Python, ~300 lines) — Links object files, produces ELF executables
3. **libc** (C, ~500 lines) — Minimal C standard library
4. **Ethernet Controller** (SystemVerilog, ~200 lines) — Network hardware
5. **Bootloader** (C, ~300 lines) — Loads kernel over ethernet

---

## 4.2 Project 1: C Compiler

**Estimated Lines:** ~2000 Haskell

### 4.2.1 Compiler Architecture

```
COMPILER PIPELINE
=================

┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│  Source  │   │  Lexer   │   │  Parser  │   │ Semantic │   │   Code   │
│   .c     │──▶│          │──▶│          │──▶│ Analysis │──▶│   Gen    │
│          │   │  Tokens  │   │   AST    │   │  Types   │   │ Assembly │
└──────────┘   └──────────┘   └──────────┘   └──────────┘   └──────────┘

Stages:
1. Lexer: Source text → Token stream
2. Parser: Tokens → Abstract Syntax Tree (AST)
3. Semantic Analysis: Type checking, symbol resolution
4. Code Generation: AST → RISC-V assembly

We skip optimization for simplicity. Output is valid but not efficient.
```

### 4.2.2 Supported C Subset

```
SUPPORTED C FEATURES
====================

Types:
  - int (32-bit signed)
  - char (8-bit)
  - void
  - Pointers to any type
  - Arrays (single dimension)
  - struct (no bitfields)

Declarations:
  - Global variables
  - Local variables
  - Function definitions
  - Function prototypes
  - typedef

Statements:
  - if / else
  - while
  - for
  - return
  - Compound statements { }
  - Expression statements

Expressions:
  - Arithmetic: + - * / %
  - Comparison: == != < > <= >=
  - Logical: && || !
  - Bitwise: & | ^ ~ << >>
  - Assignment: = += -= etc.
  - Address-of: &
  - Dereference: *
  - Array subscript: []
  - Struct member: . and ->
  - Function calls
  - Sizeof
  - Casts

NOT Supported (for simplicity):
  - float/double
  - union
  - enum
  - switch/case (use if/else chain)
  - goto
  - Multi-dimensional arrays
  - Variable-length arrays
  - Variadic functions (except printf hack)
  - Preprocessor (use external cpp)
```

### 4.2.3 Calling Convention (RISC-V ILP32)

```
RISC-V CALLING CONVENTION
=========================

Argument Registers: a0-a7 (x10-x17)
  - First 8 arguments in registers
  - Additional arguments on stack

Return Value: a0 (and a1 for 64-bit returns, not needed)

Caller-Saved (temporaries): t0-t6, a0-a7
  - Caller must save if needed across call

Callee-Saved: s0-s11, sp
  - Callee must preserve

Stack: Grows downward, sp always 16-byte aligned at call

Frame Pointer: s0/fp (optional but we'll use it)


STACK FRAME LAYOUT
==================

Higher addresses
│                    │
├────────────────────┤
│   Argument N       │  (if > 8 args)
├────────────────────┤
│   Argument 9       │
├────────────────────┤ ◀── Caller's SP before call
│   Return Address   │  (saved ra)
├────────────────────┤
│   Old Frame Ptr    │  (saved s0)
├────────────────────┤ ◀── Current FP (s0)
│   Local var 1      │
├────────────────────┤
│   Local var 2      │
├────────────────────┤
│   ...              │
├────────────────────┤
│   Saved registers  │  (s1-s11 if used)
├────────────────────┤ ◀── Current SP
│                    │
Lower addresses


FUNCTION PROLOGUE:
    addi sp, sp, -FRAME_SIZE
    sw   ra, FRAME_SIZE-4(sp)
    sw   s0, FRAME_SIZE-8(sp)
    addi s0, sp, FRAME_SIZE

FUNCTION EPILOGUE:
    lw   ra, FRAME_SIZE-4(sp)
    lw   s0, FRAME_SIZE-8(sp)
    addi sp, sp, FRAME_SIZE
    ret
```

### 4.2.4 Implementation Checklist

#### File: `tools/compiler/Main.hs`

- [ ] **Command-line parsing**
  - Input file argument
  - Output file argument (-o)
  - Optional flags: -S (assembly), -c (object)

- [ ] **Main pipeline orchestration**
  - Read source file
  - Run preprocessor (shell out to cpp)
  - Lex → Parse → Analyze → Generate
  - Write output

- [ ] **Error handling**
  - Catch and format errors from each stage
  - Report file:line:col information

#### File: `tools/compiler/Lexer.hs`

- [ ] **Token data type**
  ```haskell
  data Token
    = TokInt Integer
    | TokChar Char
    | TokString String
    | TokIdent String
    | TokKeyword Keyword
    | TokOp Operator
    | TokPunct Punctuation
    | TokEOF
    deriving (Show, Eq)
  ```

- [ ] **Keyword enumeration**
  - int, char, void, if, else, while, for, return
  - struct, typedef, sizeof

- [ ] **Operator enumeration**
  - All C operators with their spellings

- [ ] **Lexer monad**
  - Track position (line, column)
  - Handle errors with location

- [ ] **Lexer functions**
  - `lexToken :: Lexer Token`
  - `lexAll :: String -> Either Error [Token]`

- [ ] **Number literal parsing**
  - Decimal
  - Hexadecimal (0x prefix)
  - Octal (0 prefix)
  - Character literals

- [ ] **String literal parsing**
  - Handle escape sequences: \n \t \r \\ \" \0
  - Handle hex escapes: \xNN

- [ ] **Identifier/keyword discrimination**
  - Check if identifier is reserved word

- [ ] **Comment handling**
  - Single-line: //
  - Multi-line: /* */

#### File: `tools/compiler/Parser.hs`

- [ ] **AST data types**
  ```haskell
  data Program = Program [Declaration]
  
  data Declaration
    = FunDecl Type String [(Type, String)] (Maybe Statement)
    | VarDecl Type String (Maybe Expr)
    | TypeDef Type String
    | StructDecl String [(Type, String)]
  
  data Statement
    = Compound [Statement]
    | If Expr Statement (Maybe Statement)
    | While Expr Statement
    | For (Maybe Expr) (Maybe Expr) (Maybe Expr) Statement
    | Return (Maybe Expr)
    | ExprStmt Expr
    | VarDeclStmt Type String (Maybe Expr)
  
  data Expr
    = IntLit Integer
    | CharLit Char
    | StringLit String
    | Var String
    | Binary BinOp Expr Expr
    | Unary UnaryOp Expr
    | Call String [Expr]
    | Index Expr Expr
    | Member Expr String
    | PtrMember Expr String
    | Assign Expr Expr
    | Sizeof Type
    | Cast Type Expr
  
  data Type
    = TyInt
    | TyChar
    | TyVoid
    | TyPtr Type
    | TyArray Type (Maybe Integer)
    | TyStruct String
    | TyName String  -- typedef'd name
  ```

- [ ] **Parser monad**
  - Token stream state
  - Error accumulation

- [ ] **Utility combinators**
  - `expect :: Token -> Parser ()`
  - `peek :: Parser Token`
  - `consume :: Parser Token`
  - `many :: Parser a -> Parser [a]`
  - `optional :: Parser a -> Parser (Maybe a)`

- [ ] **Type parsing**
  - Base type (int, char, void, struct name)
  - Pointer stars
  - Array brackets

- [ ] **Declaration parsing**
  - Function: type name(params) { body }
  - Variable: type name = init;
  - Struct: struct name { fields };

- [ ] **Statement parsing**
  - Compound: { statements }
  - If: if (expr) stmt [else stmt]
  - While: while (expr) stmt
  - For: for (init; cond; update) stmt
  - Return: return [expr];

- [ ] **Expression parsing (precedence climbing)**
  - Implement operator precedence correctly
  - C precedence levels (15+ levels)
  - Handle left and right associativity

- [ ] **Primary expression parsing**
  - Literals
  - Identifiers
  - Parenthesized expressions
  - Sizeof

- [ ] **Postfix expression parsing**
  - Function calls
  - Array subscript
  - Member access (. and ->)
  - Post-increment/decrement

- [ ] **Unary expression parsing**
  - Prefix operators: - ! ~ * & ++ --

#### File: `tools/compiler/Semantic.hs`

- [ ] **Symbol table data structure**
  ```haskell
  data SymbolTable = SymbolTable
    { globals :: Map String Symbol
    , locals  :: [Map String Symbol]  -- stack of scopes
    , structs :: Map String StructDef
    , typedefs :: Map String Type
    }
  
  data Symbol = Symbol
    { symType :: Type
    , symKind :: SymbolKind  -- Global, Local, Param
    , symOffset :: Int       -- stack offset for locals
    }
  ```

- [ ] **Type representation with sizes**
  - sizeof(int) = 4
  - sizeof(char) = 1
  - sizeof(pointer) = 4
  - sizeof(struct) = sum of fields (with alignment)

- [ ] **Scope management**
  - Enter scope: push new map
  - Exit scope: pop map
  - Lookup: search from innermost outward

- [ ] **Type checking expressions**
  - Binary ops: check operand compatibility
  - Unary ops: check operand type
  - Assignments: check LHS is lvalue
  - Pointer arithmetic: scale by element size

- [ ] **Type checking statements**
  - If/while: condition must be scalar
  - Return: must match function return type
  - For: check all three expressions

- [ ] **Declaration checking**
  - No redefinition in same scope
  - Function prototypes match definitions
  - Struct fields have valid types

- [ ] **Implicit conversions**
  - char → int
  - Array → pointer to first element
  - Function → pointer to function

- [ ] **Error messages**
  - Type mismatch
  - Undefined identifier
  - Invalid lvalue
  - Wrong number of arguments

#### File: `tools/compiler/CodeGen.hs`

- [ ] **Code generator state**
  ```haskell
  data CodeGenState = CodeGenState
    { output :: [String]        -- assembly lines
    , labelCounter :: Int       -- for unique labels
    , stackOffset :: Int        -- current local var offset
    , stringLiterals :: [(Int, String)]  -- accumulated strings
    }
  ```

- [ ] **Global variable generation**
  - .data section
  - Labels with .word or .space directives

- [ ] **String literal handling**
  - Accumulate during codegen
  - Emit in .rodata section at end
  - Reference by generated label

- [ ] **Function code generation**
  - Emit label
  - Generate prologue
  - Generate body
  - Generate epilogue

- [ ] **Stack frame setup**
  - Calculate total size needed
  - Allocate space for locals
  - Save callee-saved registers used

- [ ] **Statement code generation**
  - Compound: generate each in sequence
  - If: generate condition, branch, then/else blocks
  - While: label, condition, body, branch back
  - For: init, label, condition, body, update, branch
  - Return: evaluate expression (if any), epilogue, ret

- [ ] **Expression code generation**
  - Result left in a0 (or wherever needed)
  - Generate code, value ends up in register or memory

- [ ] **Binary operation generation**
  - Evaluate left operand (save to temp/stack)
  - Evaluate right operand
  - Apply operation

- [ ] **Function call generation**
  - Evaluate arguments right-to-left
  - Place first 8 in a0-a7
  - Push rest to stack
  - Call instruction
  - Clean up stack
  - Result in a0

- [ ] **Address-of operator**
  - Local: compute sp + offset
  - Global: load address with la

- [ ] **Dereference operator**
  - Generate address
  - Load from that address

- [ ] **Array subscript**
  - Compute base + (index * element_size)
  - Load/store at that address

- [ ] **Struct member access**
  - Compute base + field_offset
  - Handle . (object) vs -> (pointer)

- [ ] **Assignment code generation**
  - Generate LHS address
  - Generate RHS value
  - Store RHS to LHS address
  - Leave value in a0 (for chained assignment)

- [ ] **Comparison operations**
  - Generate using SLT/SLTU + BEQ/BNE
  - Set result to 0 or 1

- [ ] **Logical operations**
  - Short-circuit evaluation for && and ||
  - Generate branches

#### File: `tools/compiler/test/TestLexer.hs`

- [ ] **Test: keywords**
  - All keywords recognized
  - Not confused with identifiers

- [ ] **Test: operators**
  - All operators including multi-char (++, <=, etc.)

- [ ] **Test: numbers**
  - Decimal, hex, octal
  - Various sizes

- [ ] **Test: strings**
  - Escape sequences
  - Empty strings

- [ ] **Test: comments**
  - Single-line
  - Multi-line
  - Nested /* not allowed

#### File: `tools/compiler/test/TestParser.hs`

- [ ] **Test: declarations**
  - Variables with/without init
  - Functions with various signatures
  - Structs

- [ ] **Test: statements**
  - All statement types
  - Nested structures

- [ ] **Test: expressions**
  - Precedence correctness
  - Associativity
  - Complex nested expressions

#### File: `tools/compiler/test/TestCodeGen.hs`

- [ ] **Test: arithmetic**
  - Compile and run, check result

- [ ] **Test: control flow**
  - If/else branches
  - Loops execute correctly

- [ ] **Test: functions**
  - Call and return
  - Arguments passed correctly

- [ ] **Test: pointers**
  - Address-of and dereference
  - Pointer arithmetic

- [ ] **End-to-end tests**
  - Compile C file
  - Assemble with our assembler
  - Run on simulated CPU
  - Check output

---

## 4.3 Project 2: Linker

**Estimated Lines:** ~300 Python

### 4.3.1 Linker Purpose

```
LINKER WORKFLOW
===============

┌──────────┐   ┌──────────┐   ┌──────────┐
│  file1.o │   │  file2.o │   │  libc.a  │
│  (object)│   │  (object)│   │(archive) │
└────┬─────┘   └────┬─────┘   └────┬─────┘
     │              │              │
     └──────────────┼──────────────┘
                    │
                    ▼
            ┌───────────────┐
            │    Linker     │
            │               │
            │ 1. Collect    │
            │    sections   │
            │ 2. Resolve    │
            │    symbols    │
            │ 3. Relocate   │
            │ 4. Output ELF │
            └───────┬───────┘
                    │
                    ▼
            ┌───────────────┐
            │  output.elf   │
            │  (executable) │
            └───────────────┘

Key concepts:
- Symbol: named address (function, variable)
- Section: chunk of code or data (.text, .data, .bss)
- Relocation: fixup for addresses not known until link time
```

### 4.3.2 ELF Format Overview

```
ELF FILE STRUCTURE
==================

┌─────────────────────────┐
│      ELF Header         │  Magic, type, machine, entry point
├─────────────────────────┤
│   Program Headers       │  Segments for loading
│   (for executable)      │
├─────────────────────────┤
│      .text              │  Code section
├─────────────────────────┤
│      .rodata            │  Read-only data (strings, etc.)
├─────────────────────────┤
│      .data              │  Initialized data
├─────────────────────────┤
│      .bss               │  Uninitialized data (zero-filled)
├─────────────────────────┤
│   Section Headers       │  Section metadata
├─────────────────────────┤
│   String Tables         │  Section/symbol names
├─────────────────────────┤
│   Symbol Table          │  All symbols
└─────────────────────────┘

ELF Header (52 bytes for ELF32):
  - Magic: 0x7F 'E' 'L' 'F'
  - Class: 32-bit (1)
  - Data: Little endian (1)
  - Type: Executable (2) or Relocatable (1)
  - Machine: RISC-V (243)
  - Entry: start address
```

### 4.3.3 Relocation Types

```
RISC-V RELOCATION TYPES
=======================

R_RISCV_32:
  - 32-bit absolute address
  - Used for: .word label

R_RISCV_CALL:
  - 32-bit PC-relative for auipc+jalr pair
  - Used for: function calls

R_RISCV_PCREL_HI20:
  - High 20 bits of PC-relative address
  - Used with: auipc

R_RISCV_PCREL_LO12_I:
  - Low 12 bits of PC-relative, I-format
  - Used with: lw, addi after auipc

R_RISCV_HI20:
  - High 20 bits of absolute address
  - Used with: lui

R_RISCV_LO12_I:
  - Low 12 bits of absolute, I-format
  - Used with: addi, lw

R_RISCV_LO12_S:
  - Low 12 bits of absolute, S-format
  - Used with: sw

R_RISCV_BRANCH:
  - 12-bit PC-relative branch offset
  - Used for: beq, bne, etc.

R_RISCV_JAL:
  - 20-bit PC-relative jump offset
  - Used for: jal
```

### 4.3.4 Implementation Checklist

#### File: `tools/linker/linker.py` (Main)

- [ ] **Command-line interface**
  - Input object files
  - Output executable (-o)
  - Entry point symbol (-e, default _start)
  - Base address (-Ttext)
  - Library search paths (-L)
  - Libraries (-l)

- [ ] **Main link() function**
  - Parse all input objects
  - Collect sections
  - Resolve symbols
  - Perform relocations
  - Write output ELF

#### File: `tools/linker/elf.py`

- [ ] **ELF header parsing/generation**
  - Read/write ELF32 header
  - Validate magic and machine type

- [ ] **Program header handling**
  - PT_LOAD segments
  - Calculate virtual addresses

- [ ] **Section header handling**
  - Parse section table
  - Different section types

- [ ] **Symbol table handling**
  - Parse symbol entries
  - Symbol binding (local, global, weak)
  - Symbol type (function, object, section)

- [ ] **Relocation handling**
  - Parse relocation entries
  - Support needed relocation types

- [ ] **String table handling**
  - Read strings by offset
  - Build string tables for output

#### File: `tools/linker/symbols.py`

- [ ] **Symbol table data structure**
  ```python
  class Symbol:
      name: str
      value: int
      size: int
      type: str  # 'function', 'object', 'section'
      binding: str  # 'local', 'global', 'weak'
      section: str
      defined: bool
  ```

- [ ] **Global symbol table**
  - Collect from all input files
  - Detect multiple definitions
  - Handle weak symbols

- [ ] **Symbol resolution**
  - Match undefined symbols to definitions
  - Error on unresolved symbols
  - Handle common symbols (.bss)

#### File: `tools/linker/sections.py`

- [ ] **Section merging**
  - Collect all .text sections → single output .text
  - Same for .data, .rodata, .bss

- [ ] **Address assignment**
  - Assign virtual addresses to sections
  - Maintain alignment requirements

- [ ] **Section output**
  - Concatenate content
  - Apply relocations

#### File: `tools/linker/relocate.py`

- [ ] **Relocation application**
  - For each relocation entry:
  - Look up symbol value
  - Calculate final value based on reloc type
  - Patch instruction/data

- [ ] **R_RISCV_32 implementation**
  - Write symbol address as 32-bit value

- [ ] **R_RISCV_CALL implementation**
  - Calculate PC-relative offset
  - Patch auipc and jalr instructions

- [ ] **R_RISCV_HI20 / LO12 implementation**
  - Calculate high/low parts
  - Patch lui/addi or auipc/addi

- [ ] **R_RISCV_BRANCH implementation**
  - Calculate PC-relative offset
  - Check range (±4KB)
  - Patch branch instruction

- [ ] **R_RISCV_JAL implementation**
  - Calculate PC-relative offset
  - Check range (±1MB)
  - Patch jal instruction

#### File: `tools/linker/output.py`

- [ ] **ELF executable generation**
  - Build ELF header
  - Build program headers
  - Build section headers
  - Write sections
  - Write symbol table (optional, for debugging)

- [ ] **Binary output option**
  - Raw binary, no ELF headers
  - For direct loading into memory

#### File: `tools/linker/test_linker.py`

- [ ] **Test: simple_link**
  - Link single object file
  - Verify ELF is valid

- [ ] **Test: multiple_files**
  - Link multiple objects
  - Verify cross-file references resolved

- [ ] **Test: relocation_types**
  - Test each relocation type
  - Verify correct patching

- [ ] **Test: symbol_resolution**
  - Global symbols found
  - Error on undefined
  - Weak symbol handling

- [ ] **Test: with_qemu**
  - Link test program
  - Run on QEMU (riscv32)
  - Verify correct execution

---

## 4.4 Project 3: Minimal libc

**Estimated Lines:** ~500 C

### 4.4.1 libc Components

```
MINIMAL LIBC STRUCTURE
======================

sw/libc/
├── include/
│   ├── stddef.h      # NULL, size_t, ptrdiff_t
│   ├── stdint.h      # int32_t, uint8_t, etc.
│   ├── stdbool.h     # bool, true, false
│   ├── string.h      # memcpy, memset, strlen, etc.
│   ├── stdio.h       # printf, putchar, getchar
│   └── stdlib.h      # malloc, free, exit
├── src/
│   ├── string.c      # String functions
│   ├── stdio.c       # I/O functions
│   ├── stdlib.c      # Memory allocation
│   ├── crt0.s        # C runtime startup
│   └── syscalls.c    # System call wrappers (later)
└── Makefile

Note: No syscalls yet! I/O goes directly to UART hardware.
Syscalls added when we have an OS (Section 5).
```

### 4.4.2 Implementation Checklist

#### File: `sw/libc/include/stddef.h`

- [ ] **NULL definition**
  - `#define NULL ((void*)0)`

- [ ] **size_t definition**
  - `typedef unsigned int size_t;`

- [ ] **ptrdiff_t definition**
  - `typedef int ptrdiff_t;`

- [ ] **offsetof macro**
  - `#define offsetof(type, member) ...`

#### File: `sw/libc/include/stdint.h`

- [ ] **Fixed-width types**
  - int8_t, int16_t, int32_t
  - uint8_t, uint16_t, uint32_t

- [ ] **Pointer-sized types**
  - intptr_t, uintptr_t

- [ ] **Limits**
  - INT32_MAX, INT32_MIN, UINT32_MAX, etc.

#### File: `sw/libc/include/string.h`

- [ ] **Function declarations**
  - memcpy, memmove, memset, memcmp
  - strlen, strcpy, strncpy, strcmp, strncmp
  - strchr, strrchr, strstr

#### File: `sw/libc/src/string.c`

- [ ] **memcpy()**
  - Copy n bytes from src to dest
  - Assume no overlap (use memmove for that)

- [ ] **memmove()**
  - Copy with possible overlap
  - Copy forward or backward as needed

- [ ] **memset()**
  - Fill n bytes with value

- [ ] **memcmp()**
  - Compare n bytes
  - Return <0, 0, or >0

- [ ] **strlen()**
  - Count bytes until null terminator

- [ ] **strcpy() / strncpy()**
  - Copy string with/without length limit

- [ ] **strcmp() / strncmp()**
  - Compare strings lexicographically

- [ ] **strchr() / strrchr()**
  - Find character from start/end

- [ ] **strstr()**
  - Find substring

#### File: `sw/libc/include/stdio.h`

- [ ] **putchar() declaration**
- [ ] **getchar() declaration**
- [ ] **puts() declaration**
- [ ] **printf() declaration**
- [ ] **sprintf() declaration**

#### File: `sw/libc/src/stdio.c`

- [ ] **UART register addresses**
  - Define base address and offsets
  - Or accept as global variable

- [ ] **putchar()**
  - Poll TX ready
  - Write to TX data register

- [ ] **getchar()**
  - Poll RX valid
  - Read from RX data register

- [ ] **puts()**
  - Output string + newline

- [ ] **printf() implementation**
  - Parse format string
  - Support: %d, %u, %x, %X, %s, %c, %p, %%
  - Support: width, zero-padding
  - Field width (optional)
  - No floating point

- [ ] **sprintf()**
  - Like printf but to buffer

- [ ] **Internal: print_int()**
  - Convert integer to string
  - Handle signed/unsigned
  - Handle different bases

#### File: `sw/libc/include/stdlib.h`

- [ ] **malloc() / free() declarations**
- [ ] **exit() declaration**
- [ ] **atoi() declaration**

#### File: `sw/libc/src/stdlib.c`

- [ ] **Heap setup**
  - Heap start address (linker-defined symbol)
  - Heap end address (or size)

- [ ] **malloc() implementation**
  - Simple allocator (bump pointer or free list)
  - Track allocated blocks

- [ ] **free() implementation**
  - Mark block as free
  - (simple version: do nothing)

- [ ] **Heap data structures**
  ```c
  struct block_header {
      size_t size;
      int free;
      struct block_header *next;
  };
  ```

- [ ] **atoi()**
  - Parse integer from string
  - Handle negative

- [ ] **exit()**
  - For now: infinite loop
  - Later: syscall to OS

#### File: `sw/libc/src/crt0.s`

- [ ] **_start entry point**
  - Set up stack pointer
  - Clear .bss section
  - Call main()
  - Call exit() with return value

- [ ] **BSS clearing**
  - Use linker symbols for start/end
  - Zero all bytes

```asm
.section .text.start
.global _start
_start:
    # Set stack pointer
    la sp, __stack_top
    
    # Clear BSS
    la t0, __bss_start
    la t1, __bss_end
clear_bss:
    bge t0, t1, done_bss
    sw zero, 0(t0)
    addi t0, t0, 4
    j clear_bss
done_bss:
    
    # Call main
    call main
    
    # Exit with return value
    mv a0, a0
    call exit
```

#### File: `sw/libc/Makefile`

- [ ] **Compile all .c files to .o**
- [ ] **Assemble .s files**
- [ ] **Create static library (libc.a)**
- [ ] **Install headers to include path**

#### File: `sw/libc/test/test_string.c`

- [ ] **Test all string functions**
  - Edge cases: empty strings, NULL
  - Various lengths

#### File: `sw/libc/test/test_printf.c`

- [ ] **Test format specifiers**
  - %d, %u, %x with various values
  - Width and padding
  - %s and %c

#### File: `sw/libc/test/test_malloc.c`

- [ ] **Test allocation**
  - Various sizes
  - Multiple allocations
  - Free and reallocate

---

## 4.5 Project 4: Ethernet Controller

**Estimated Lines:** ~200 SystemVerilog

### 4.5.1 Ethernet Basics

```
ETHERNET FRAME FORMAT
=====================

┌─────────┬─────────┬──────┬────────────────┬─────┐
│Preamble │  SFD    │Header│    Payload     │ FCS │
│ 7 bytes │ 1 byte  │14 B  │  46-1500 bytes │4 B  │
└─────────┴─────────┴──────┴────────────────┴─────┘

Preamble: 10101010 × 7 (clock sync)
SFD: Start Frame Delimiter: 10101011
Header:
  - Dest MAC: 6 bytes
  - Src MAC: 6 bytes
  - EtherType: 2 bytes (0x0800 = IPv4)
Payload: Data
FCS: Frame Check Sequence (CRC-32)


MII INTERFACE (Media Independent Interface)
===========================================

From PHY to MAC (receive):
  RX_CLK  ────▶  Clock (25 MHz for 100Mbps)
  RXD[3:0] ───▶  Receive data (4 bits per clock)
  RX_DV   ────▶  Receive data valid
  RX_ER   ────▶  Receive error

From MAC to PHY (transmit):
  TX_CLK  ◀────  Clock (from PHY)
  TXD[3:0] ◀───  Transmit data
  TX_EN   ◀────  Transmit enable

Management:
  MDC     ◀────  Management clock
  MDIO    ◀───▶  Management data (bidirectional)

Note: For 10Mbps, use 2.5 MHz clock
      For 100Mbps, use 25 MHz clock
      We'll target 100Mbps
```

### 4.5.2 Ethernet Controller Block Diagram

```
ETHERNET MAC BLOCK DIAGRAM
==========================

┌────────────────────────────────────────────────────────────────────────┐
│                         ethernet_mac                                    │
│                                                                        │
│  MMIO Interface                                                        │
│  ┌──────────────────────────────────────────────────────────────────┐ │
│  │  0x00: TX_BUFFER (write packet data)                             │ │
│  │  0x04: TX_LEN (write to start transmission)                      │ │
│  │  0x08: TX_STATUS (read: busy, done)                              │ │
│  │  0x10: RX_BUFFER (read packet data)                              │ │
│  │  0x14: RX_LEN (read: received length)                            │ │
│  │  0x18: RX_STATUS (read: available, overflow)                     │ │
│  │  0x20: MAC_ADDR_LO (read/write)                                  │ │
│  │  0x24: MAC_ADDR_HI (read/write)                                  │ │
│  └──────────────────────────────────────────────────────────────────┘ │
│                                                                        │
│  ┌──────────────────┐              ┌──────────────────┐               │
│  │   TX Path        │              │   RX Path        │               │
│  │                  │              │                  │               │
│  │ ┌──────────────┐ │              │ ┌──────────────┐ │               │
│  │ │  TX Buffer   │ │              │ │  RX Buffer   │ │               │
│  │ │  (BRAM)      │ │              │ │  (BRAM)      │ │               │
│  │ └──────────────┘ │              │ └──────────────┘ │               │
│  │       │         │              │       ▲         │               │
│  │       ▼         │              │       │         │               │
│  │ ┌──────────────┐ │              │ ┌──────────────┐ │               │
│  │ │   TX FSM     │ │              │ │   RX FSM     │ │               │
│  │ │ + CRC Gen    │ │              │ │ + CRC Check  │ │               │
│  │ └──────────────┘ │              │ └──────────────┘ │               │
│  │       │         │              │       ▲         │               │
│  └───────┼─────────┘              └───────┼─────────┘               │
│          ▼                                │                          │
│     ┌─────────┐                      ┌─────────┐                     │
│     │  MII    │                      │  MII    │                     │
│     │   TX    │                      │   RX    │                     │
│     └────┬────┘                      └────┬────┘                     │
│          │                                │                          │
└──────────┼────────────────────────────────┼──────────────────────────┘
           ▼                                ▲
      TXD, TX_EN                       RXD, RX_DV
      (to PHY)                         (from PHY)
```

### 4.5.3 Implementation Checklist

#### File: `rtl/peripherals/ethernet_mac.sv`

- [ ] **Module ports**
  - Clock/reset (system clock domain)
  - MMIO interface: addr, wdata, rdata, wen, ren
  - MII interface: all signals listed above

- [ ] **TX buffer (BRAM)**
  - 2KB buffer (holds max frame)
  - Dual-port: CPU write, TX FSM read

- [ ] **RX buffer (BRAM)**
  - 2KB buffer
  - Dual-port: RX FSM write, CPU read

- [ ] **Register file**
  - TX length register
  - TX status register
  - RX length register
  - RX status register
  - MAC address registers

#### File: `rtl/peripherals/eth_tx.sv`

- [ ] **TX state machine**
  ```
  IDLE → PREAMBLE → SFD → DATA → FCS → IPG → IDLE
  ```

- [ ] **Preamble generation**
  - 7 bytes of 0x55

- [ ] **SFD generation**
  - 1 byte of 0xD5 (reversed: 10101011)

- [ ] **Data transmission**
  - Read from buffer
  - Output nibble by nibble (4 bits per MII clock)

- [ ] **CRC-32 generation**
  - Calculate CRC as data is sent
  - Append 4 bytes at end

- [ ] **Inter-packet gap**
  - Wait 96 bit times (12 bytes) between frames

- [ ] **MII timing**
  - Clock domain crossing if needed
  - Or assume same clock

#### File: `rtl/peripherals/eth_rx.sv`

- [ ] **RX state machine**
  ```
  IDLE → PREAMBLE → DATA → DONE
  ```

- [ ] **Preamble detection**
  - Wait for RX_DV
  - Skip preamble and SFD

- [ ] **Data reception**
  - Store nibbles, assemble bytes
  - Write to RX buffer

- [ ] **CRC-32 checking**
  - Calculate CRC as data received
  - Verify matches received FCS
  - Discard frame if CRC error

- [ ] **Frame complete handling**
  - Set RX status
  - Store length
  - Handle buffer overflow

#### File: `rtl/peripherals/eth_crc.sv`

- [ ] **CRC-32 module**
  - Polynomial: 0x04C11DB7
  - Process 4 bits (nibble) per cycle
  - Initial value: 0xFFFFFFFF
  - Final XOR: 0xFFFFFFFF
  - Bit reversal for Ethernet

- [ ] **Interface**
  - Input: nibble, enable, clear
  - Output: current CRC value

#### File: `tb/test_ethernet.py`

- [ ] **Helper: generate_frame()**
  - Create valid Ethernet frame
  - Calculate correct CRC

- [ ] **Test: transmit_frame**
  - Write frame to TX buffer
  - Start transmission
  - Capture MII output
  - Verify frame format and CRC

- [ ] **Test: receive_frame**
  - Drive MII RX signals with valid frame
  - Read from RX buffer
  - Verify data matches

- [ ] **Test: crc_check**
  - Send frame with bad CRC
  - Verify rejected

- [ ] **Test: back_to_back**
  - Send multiple frames
  - Verify all received

---

## 4.6 Project 5: Bootloader

**Estimated Lines:** ~300 C

### 4.6.1 Bootloader Purpose

```
BOOTLOADER FLOW
===============

1. Bootrom runs, loads bootloader from serial (or embedded)
2. Bootloader initializes hardware:
   - Memory controller (if needed)
   - Ethernet MAC
3. Bootloader sends BOOTP/DHCP request
4. Bootloader receives kernel location (TFTP server)
5. Bootloader downloads kernel via TFTP over UDP
6. Bootloader jumps to kernel entry point

Simpler alternative (for now):
- Skip DHCP
- Use hardcoded IP addresses
- Simple UDP protocol: "BOOT" request → receive kernel


MEMORY MAP WITH BOOTLOADER
==========================

0x00000000 - 0x00000FFF: Boot ROM (4KB)
0x10000000 - 0x10003FFF: Bootloader (16KB)
0x10004000 - 0x100FFFFF: Kernel load area (~1MB)
0x10100000 - 0x101FFFFF: Kernel heap
0x20000000 - 0x200000FF: UART
0x20000100 - 0x200001FF: Ethernet MAC
```

### 4.6.2 Network Protocol Stack (Minimal)

```
MINIMAL NETWORK STACK
=====================

For bootloader, we only need:
- Ethernet: frame TX/RX
- ARP: IP to MAC address resolution (optional, can hardcode)
- IP: Packet routing (no fragmentation)
- UDP: Connectionless datagrams

No TCP needed (too complex for bootloader)

PACKET STRUCTURE:
┌─────────────┐
│  Ethernet   │ 14 bytes
├─────────────┤
│     IP      │ 20 bytes (no options)
├─────────────┤
│    UDP      │ 8 bytes
├─────────────┤
│   Payload   │ variable
└─────────────┘


UDP BOOT PROTOCOL (Simple Custom)
=================================

Client (bootloader) → Server:
  Port 6969 (nice)
  Payload: "BOOT\0" + MAC address (6 bytes)

Server → Client:
  Payload: [total_size:4][offset:4][chunk_size:4][data:chunk_size]
  
  Repeat until all chunks received
  
  Final ACK from client: "DONE\0"
```

### 4.6.3 Implementation Checklist

#### File: `sw/bootloader/main.c`

- [ ] **main() function**
  - Initialize hardware
  - Initialize network
  - Request boot image
  - Load image to memory
  - Jump to kernel

- [ ] **Hardware initialization**
  - Set MAC address
  - Enable ethernet

#### File: `sw/bootloader/eth.c`

- [ ] **eth_init()**
  - Configure MAC address
  - Enable RX/TX

- [ ] **eth_send()**
  - Copy frame to TX buffer
  - Set length, start TX
  - Wait for completion

- [ ] **eth_recv()**
  - Check for received frame
  - Copy from RX buffer
  - Return length (0 if none)

- [ ] **eth_poll()**
  - Non-blocking receive check

#### File: `sw/bootloader/ip.c`

- [ ] **IP address configuration**
  - Our IP (hardcoded or DHCP later)
  - Server IP (hardcoded)
  - Gateway (if needed)
  - Netmask

- [ ] **ip_send()**
  - Build IP header
  - Calculate checksum
  - Call eth_send()

- [ ] **ip_recv()**
  - Validate IP header
  - Check destination IP
  - Return payload to upper layer

- [ ] **IP checksum calculation**
  - 16-bit ones' complement sum

#### File: `sw/bootloader/udp.c`

- [ ] **udp_send()**
  - Build UDP header
  - src_port, dst_port, length
  - Checksum (optional, can be 0)
  - Call ip_send()

- [ ] **udp_recv()**
  - Parse UDP header
  - Filter by port
  - Return payload

- [ ] **udp_bind()**
  - Set port to listen on

#### File: `sw/bootloader/arp.c` (Optional)

- [ ] **ARP cache**
  - Small table of IP→MAC mappings

- [ ] **arp_request()**
  - Send ARP request for IP

- [ ] **arp_process()**
  - Handle incoming ARP
  - Update cache

- [ ] **arp_resolve()**
  - Look up or request MAC for IP

#### File: `sw/bootloader/boot_protocol.c`

- [ ] **boot_request()**
  - Send boot request packet
  - Wait for response
  - Handle timeout/retry

- [ ] **boot_receive_image()**
  - Receive chunks
  - Write to memory
  - Track progress
  - Send ACKs

- [ ] **boot_jump()**
  - Jump to loaded image
  - Pass any boot parameters

#### File: `sw/bootloader/linker.ld`

- [ ] **Memory regions**
  - ROM/RAM locations
  - Stack placement

- [ ] **Sections**
  - .text at start
  - .rodata after
  - .data (initialized)
  - .bss (zeroed)

#### File: `sw/bootloader/Makefile`

- [ ] **Compile with our compiler**
- [ ] **Link with our linker**
- [ ] **Generate binary for ROM**
- [ ] **Or ELF for serial loading**

#### File: `tools/bootserver/bootserver.py`

- [ ] **UDP server**
  - Listen on port 6969
  - Receive boot requests

- [ ] **Image serving**
  - Load kernel binary
  - Send in chunks
  - Handle ACKs

- [ ] **Command line**
  - Kernel image argument
  - Network interface selection

---

## 4.7 Integration: First C Program

### 4.7.1 Hello World Test

```c
// sw/test/hello.c
#include <stdio.h>

int main(void) {
    printf("Hello from RISC-V!\n");
    return 0;
}
```

### 4.7.2 Build and Run Steps

```bash
# 1. Compile C to assembly
./tools/compiler/centurion-cc -S hello.c -o hello.s

# 2. Assemble to object file
./tools/assembler/riscv-asm hello.s -o hello.o

# 3. Link with libc
./tools/linker/linker hello.o libc.a -o hello.elf

# 4. Run in simulation
make -C sim run PROGRAM=hello.elf

# Or run on QEMU for validation
qemu-system-riscv32 -nographic -machine virt -kernel hello.elf
```

---

## 4.8 Concepts to Internalize

Before proceeding to Section 5:

1. **Compilation vs Interpretation**: Static translation vs runtime evaluation
2. **Calling conventions**: How functions communicate
3. **Memory layout**: Stack, heap, data, code segments
4. **Linking**: Symbol resolution, relocation
5. **ELF format**: Standard executable format
6. **Ethernet framing**: How packets are structured
7. **UDP simplicity**: Connectionless, unreliable, but simple

---

## 4.9 Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| Operator precedence wrong | Use standard C precedence table |
| Stack frame size miscalculation | Account for alignment, all saved registers |
| Relocation overflow | Check ranges, use multi-instruction sequences |
| printf buffer overflow | Size buffer correctly, or use streaming |
| Ethernet byte order | Network byte order is big-endian |
| CRC calculation | Mind bit reversal and final XOR |
