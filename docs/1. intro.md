# Section 1: Intro — Cheating Our Way Past the Transistor

**Duration:** 0.5 weeks  
**Prerequisites:** Basic programming knowledge, familiarity with command line

---

## 1.1 Course Philosophy

This course builds a complete computer system from logic gates to a web browser. Every component builds upon the previous one—there are no shortcuts or black boxes. By the end, you will have:

- A working RISC-V processor
- A C compiler targeting your processor
- A Unix-like operating system
- A TCP/IP network stack
- A text-based web browser

All running on hardware you understand completely.

---

## 1.2 Cheating Past the Transistor

### 1.2.1 The Transistor Problem

Modern digital systems are built from transistors—tiny semiconductor switches that form the foundation of all computing. A single modern CPU contains billions of them. We cannot reasonably:

- Fabricate our own transistors (requires a semiconductor fab)
- Hand-wire billions of components
- Debug analog electronics at this scale

**Our Solution:** We accept transistors as our atomic primitive and build everything above them.

### 1.2.2 From Transistors to Logic Gates

```
TRANSISTOR FUNDAMENTALS (Conceptual Only)
=========================================

NMOS Transistor:
    Gate ──┐
           │
    Source─┴─Drain
    
    - When Gate is HIGH: conducts (switch closed)
    - When Gate is LOW: does not conduct (switch open)

PMOS Transistor:
    - Opposite behavior: conducts when Gate is LOW

CMOS NAND Gate (2-input):
    
         VDD
          │
       ┌──┴──┐
       │PMOS │──┬── PMOS
       └──┬──┘  │   
    A ────┤     ├──── B
          │     │
          └──┬──┘
             │
             ├─────── Output
             │
          ┌──┴──┐
    A ────┤NMOS │
          └──┬──┘
          ┌──┴──┐
    B ────┤NMOS │
          └──┬──┘
             │
            GND

NAND is universal: any logic function can be built from NANDs.
```

### 1.2.3 Integrated Circuits: Transistors in a Package

An IC (Integrated Circuit) is simply:
- Millions/billions of transistors
- Fabricated on silicon
- Connected by metal layers
- Packaged with pins for external connection

Key insight: **ICs hide complexity but don't add magic.** Everything inside is just transistors connected in specific patterns.

---

## 1.3 Understanding FPGAs

### 1.3.1 What is an FPGA?

An FPGA (Field-Programmable Gate Array) is an IC containing:
- A grid of configurable logic blocks
- Programmable interconnects between blocks
- Configuration memory (usually SRAM)
- Hard blocks (RAM, DSPs, PLLs)

```
FPGA ARCHITECTURE (Simplified)
==============================

┌─────────────────────────────────────────────────────────┐
│  ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐        │
│  │ IOB │   │ IOB │   │ IOB │   │ IOB │   │ IOB │        │
│  └──┬──┘   └──┬──┘   └──┬──┘   └──┬──┘   └──┬──┘        │
│     │         │         │         │         │           │
│  ┌──┴──┐   ┌──┴──┐   ┌──┴──┐   ┌──┴──┐   ┌──┴──┐        │
│  │ CLB │───│ CLB │───│ CLB │───│ CLB │───│ CLB │        │
│  └──┬──┘   └──┬──┘   └──┬──┘   └──┬──┘   └──┬──┘        │
│     │         │         │         │         │           │
│  ┌──┴──┐   ┌──┴──┐  ┌────────┐ ┌──┴──┐   ┌──┴──┐        │
│  │ CLB │───│ CLB │──│  BRAM  │─│ CLB │───│ CLB │        │
│  └──┬──┘   └──┬──┘  └────────┘ └──┬──┘   └──┬──┘        │
│     │         │         │         │         │           │
│  ┌──┴──┐   ┌──┴──┐   ┌──┴──┐   ┌──┴──┐   ┌──┴──┐        │
│  │ CLB │───│ CLB │───│ CLB │───│ CLB │───│ CLB │        │
│  └─────┘   └─────┘   └─────┘   └─────┘   └─────┘        │
│                                                         │
│  IOB = I/O Block    CLB = Configurable Logic Block      │
│  BRAM = Block RAM   ─── = Programmable Interconnect     │
└─────────────────────────────────────────────────────────┘
```

### 1.3.2 The Lookup Table (LUT)

The core of FPGA logic is the **LUT (Lookup Table)**:

```
4-INPUT LUT STRUCTURE
=====================

Inputs: A, B, C, D (4 bits = 16 combinations)
Output: Programmed truth table result

        ┌─────────────────────────┐
        │     16x1 SRAM Array     │
        │  ┌───┬───┬───┬───┐      │
   A ───┼──┤   │   │   │   │      │
   B ───┼──┤ M │ U │ X │   │──────┼──── Output
   C ───┼──┤   │   │   │   │      │
   D ───┼──┤   │   │   │   │      │
        │  └───┴───┴───┴───┘      │
        │   16:1 Multiplexer      │
        └─────────────────────────┘

Example: Programming a 2-input AND gate (using inputs A, B)

Address (DCBA) │ Stored Value │ Meaning
──────────────┼──────────────┼─────────
0000          │ 0            │ 0 AND 0 = 0
0001          │ 0            │ 0 AND 1 = 0
0010          │ 0            │ 1 AND 0 = 0
0011          │ 1            │ 1 AND 1 = 1
0100-1111     │ (don't care) │ (C,D unused)
```

**Key Insight:** A 4-input LUT can implement ANY 4-input boolean function. Modern FPGAs use 6-input LUTs (64 SRAM cells each).

### 1.3.3 Configurable Logic Block (CLB)

A CLB contains multiple LUTs plus flip-flops:

```
SIMPLIFIED CLB STRUCTURE
========================

              ┌───────────────────────────────────┐
              │            CLB                    │
              │  ┌──────┐                         │
   Inputs ────┼──│ LUT  │──┬────────────┬─────────┼──── Combinational Out
              │  └──────┘  │            │         │
              │            │   ┌────┐   │         │
              │            └───│ FF │───┴─────────┼──── Registered Out
              │                └────┘             │
              │                  ↑                │
   Clock ─────┼──────────────────┘                │
              │                                   │
              │  (Repeated for multiple LUTs)     │
              └───────────────────────────────────┘

FF = Flip-Flop (1-bit register, captures value on clock edge)
```

### 1.3.4 Programmable Interconnect

The routing between CLBs is equally important:

```
SWITCH MATRIX
=============

      North
        │
   ┌────┴────┐
   │ ┌─┐ ┌─┐ │
───┼─┤ ├─┤ ├─┼─── East
   │ └─┘ └─┘ │
   │ ┌─┐ ┌─┐ │
───┼─┤ ├─┤ ├─┼─── 
   │ └─┘ └─┘ │
   └────┬────┘
        │
      South

Each crossing point has a programmable switch.
Configuration bits determine which wires connect.
```

### 1.3.5 Block RAM (BRAM)

FPGAs contain dedicated memory blocks:

```
BLOCK RAM CHARACTERISTICS
=========================

Typical BRAM block:
- 18Kb or 36Kb capacity
- Dual-ported (two independent read/write ports)
- Synchronous (reads/writes happen on clock edge)
- Configurable width: 1, 2, 4, 9, 18, 36 bits

┌─────────────────────────────────────────┐
│              BRAM (36Kb)                │
│                                         │
│  Port A                    Port B       │
│  ┌─────┐                  ┌─────┐       │
│  │Addr │                  │Addr │       │
│  │Data │    ┌────────┐    │Data │       │
│  │WrEn │────│ Memory │────│WrEn │       │
│  │RdEn │    │ Array  │    │RdEn │       │
│  │Clk  │    └────────┘    │Clk  │       │
│  └─────┘                  └─────┘       │
└─────────────────────────────────────────┘

For our CPU: We'll use BRAM for instruction and data memory.
A mid-range FPGA might have 1-4MB of total BRAM.
```

---

## 1.4 Hardware Description Languages

### 1.4.1 HDL vs Programming Languages

Hardware Description Languages describe **structure and behavior of circuits**, not sequential instructions:

| Aspect | Software (C/Python) | Hardware (SystemVerilog) |
|--------|---------------------|--------------------------|
| Execution | Sequential | Parallel (everything runs simultaneously) |
| Variables | Memory locations | Wires or registers |
| Assignment | Copy value | Connect wires / clock-triggered storage |
| Loops | Repeat execution | Generate replicated hardware |

### 1.4.2 Why SystemVerilog?

We use **SystemVerilog** instead of plain Verilog for:

- Better type system (`logic` instead of `wire`/`reg` confusion)
- `always_comb`, `always_ff` blocks with clear intent
- Interfaces for cleaner module connections
- Packages for shared definitions
- Better simulation/verification features

### 1.4.3 Combinational vs Sequential Logic

```
COMBINATIONAL LOGIC                    SEQUENTIAL LOGIC
===================                    ================

Output depends only                    Output depends on
on current inputs                      current inputs AND
                                       previous state

   A ──┬──[AND]──┬── Y                    ┌────┐
   B ──┘         │                   D ───│ FF │─── Q
                 │                   CLK ─│    │
   Y = A & B     │                        └────┘
                 │
                 │                   Q follows D on clock edge
No memory        │                   Has memory (state)

SystemVerilog:                        SystemVerilog:

always_comb begin                     always_ff @(posedge clk) begin
    y = a & b;                            q <= d;
end                                   end
```

---

## 1.5 Emulation with Verilator

### 1.5.1 Why Emulation?

Building on real FPGA hardware has drawbacks:
- Requires purchasing hardware (~$50-500)
- Limits course accessibility
- Debugging is harder (limited visibility)
- Iteration is slower (synthesis takes minutes)

**Verilator** compiles SystemVerilog to optimized C++:
- Runs on any computer
- 10-100x faster than traditional simulators
- Full waveform visibility for debugging
- Free and open source

### 1.5.2 Verilator Architecture

```
VERILATOR COMPILATION FLOW
==========================

┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ SystemVerilog│     │   Verilator  │     │    C++       │
│    Source    │────▶│   Compiler   │────▶│   Model      │
│  (.sv files) │     │              │     │  (.cpp/.h)   │
└──────────────┘     └──────────────┘     └──────────────┘
                                                 │
                                                 ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  Executable  │◀────│  C++ Compiler│◀────│  Testbench   │
│  Simulation  │     │   (g++/clang)│     │   (C++)      │
└──────────────┘     └──────────────┘     └──────────────┘
        │
        ▼
┌──────────────┐
│   Waveform   │
│  (.vcd/.fst) │
└──────────────┘
```

### 1.5.3 cocotb: Python Testbenches

Instead of writing testbenches in C++ or SystemVerilog, we use **cocotb**:

- Write testbenches in Python
- Coroutine-based (async/await)
- Rich assertion library
- Easy integration with pytest

```
COCOTB ARCHITECTURE
===================

┌────────────────────────────────────────────────────────┐
│                    Python Testbench                    │
│  ┌─────────────────────────────────────────────────┐   │
│  │  @cocotb.test()                                 │   │
│  │  async def test_example(dut):                   │   │
│  │      dut.input.value = 5                        │   │
│  │      await RisingEdge(dut.clk)                  │   │
│  │      assert dut.output.value == 10              │   │
│  └─────────────────────────────────────────────────┘   │
└───────────────────────────┬────────────────────────────┘
                            │ VPI/VHPI Interface
                            ▼
┌────────────────────────────────────────────────────────┐
│              Verilator Simulation Model                │
│         (Your SystemVerilog design compiled)           │
└────────────────────────────────────────────────────────┘
```

---

## 1.6 Development Environment Setup

### 1.6.1 Required Tools

| Tool | Purpose | Installation |
|------|---------|--------------|
| Verilator | SystemVerilog simulation | `brew install verilator` / `apt install verilator` |
| cocotb | Python testbenches | `pip install cocotb` |
| GTKWave | Waveform viewer | `brew install gtkwave` / `apt install gtkwave` |
| Python 3.9+ | Assembler, linker, scripts | System package manager |
| GHC + Stack | Haskell for compiler | `brew install ghc stack` |
| riscv-gnu-toolchain | Reference assembler/linker | Build from source or package |

### 1.6.2 Project Structure

```
centurion/
├── rtl/                    # SystemVerilog source
│   ├── core/               # CPU core
│   ├── soc/                # System-on-chip integration
│   └── peripherals/        # UART, ethernet, etc.
├── tb/                     # cocotb testbenches
├── tools/
│   ├── assembler/          # Python RISC-V assembler
│   ├── linker/             # Python linker
│   └── compiler/           # Haskell C compiler
├── sw/
│   ├── bootrom/            # Assembly bootrom
│   ├── bootloader/         # C bootloader
│   ├── libc/               # Minimal C library
│   ├── kernel/             # Operating system
│   └── user/               # User programs
├── sim/                    # Simulation scripts
├── synth/                  # Synthesis scripts (for real FPGA)
└── docs/                   # Documentation
```

---

## 1.7 Implementation Checklist

### 1.7.1 Environment Setup Tasks

- [ ] **Install Verilator**
  - Verify version >= 5.0
  - Run `verilator --version`
  
- [ ] **Install cocotb**
  - `pip install cocotb cocotb-bus cocotb-coverage`
  - Verify: `python -c "import cocotb; print(cocotb.__version__)"`

- [ ] **Install GTKWave**
  - Verify waveform viewing with sample .vcd file
  
- [ ] **Install Python dependencies**
  - `pip install pytest pytest-asyncio`
  
- [ ] **Install Haskell toolchain**
  - GHC >= 9.0
  - Stack or Cabal
  
- [ ] **Create project directory structure**
  - Create all directories listed above
  - Initialize git repository
  - Create .gitignore for build artifacts

### 1.7.2 Verification Tasks

- [ ] **Create minimal SystemVerilog module**
  - Simple AND gate
  - Verify Verilator compiles it
  
- [ ] **Create minimal cocotb test**
  - Test the AND gate
  - Verify test runs and passes
  - Verify waveform generation
  
- [ ] **View waveforms in GTKWave**
  - Open generated .vcd/.fst file
  - Add signals to viewer
  - Navigate timeline

---

## 1.8 Concepts to Internalize

Before proceeding, ensure you understand:

1. **Parallelism**: In hardware, everything happens at once unless explicitly sequenced
2. **Clocking**: Sequential logic only changes state on clock edges
3. **Synthesis vs Simulation**: Not all valid SystemVerilog is synthesizable
4. **Timing**: Signals take time to propagate; this limits clock speed
5. **Resource tradeoffs**: More logic = more area = more power = potentially slower

---

## 1.9 Further Reading

- *"Digital Design and Computer Architecture: RISC-V Edition"* by Harris & Harris
- Patterson & Hennessy: *"Computer Organization and Design: RISC-V Edition"*
- Verilator documentation: https://verilator.org/guide/latest/
- cocotb documentation: https://docs.cocotb.org/
- FPGA architecture papers from Xilinx/Intel
