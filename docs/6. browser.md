# Section 6: Browser — Coming Online

**Duration:** 1 week  
**Prerequisites:** Section 5 (Working OS with networking hardware)  
**Language:** C (all components)

---

## 6.1 Overview

This section brings the system online with networking:

1. **TCP Stack** (C, ~500 lines) — Reliable transport protocol
2. **telnetd** (C, ~50 lines) — Remote shell access
3. **Dynamic Linker** (C, ~300 lines) — Shared library support
4. **Web Browser** (C, ~500+ lines) — Text-based HTTP client

---

## 6.2 Project 1: TCP/IP Stack

**Estimated Lines:** ~500 C

### 6.2.1 Protocol Stack Architecture

```
NETWORK STACK LAYERS
====================

┌─────────────────────────────────────────────────────────────┐
│                    APPLICATION LAYER                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │
│  │  HTTP   │  │ telnet  │  │   DNS   │  │   ...   │        │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘        │
└───────┼────────────┼────────────┼────────────┼──────────────┘
        │            │            │            │
        └────────────┴────────┬───┴────────────┘
                              │
┌─────────────────────────────┼───────────────────────────────┐
│                    TRANSPORT LAYER                           │
│                             ▼                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                Socket Interface                         │ │
│  │  socket(), bind(), listen(), accept(),                 │ │
│  │  connect(), send(), recv(), close()                    │ │
│  └────────────────────────────────────────────────────────┘ │
│                             │                               │
│         ┌───────────────────┴───────────────────┐          │
│         ▼                                       ▼          │
│  ┌─────────────┐                         ┌─────────────┐   │
│  │    TCP      │                         │    UDP      │   │
│  │ (reliable)  │                         │(unreliable) │   │
│  └──────┬──────┘                         └──────┬──────┘   │
│         │                                       │          │
└─────────┼───────────────────────────────────────┼──────────┘
          │                                       │
          └───────────────────┬───────────────────┘
                              │
┌─────────────────────────────┼───────────────────────────────┐
│                    NETWORK LAYER                             │
│                             ▼                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                        IP                               │ │
│  │            (routing, fragmentation)                     │ │
│  └────────────────────────────────────────────────────────┘ │
│                             │                               │
│                     ┌───────┴───────┐                      │
│                     ▼               ▼                      │
│              ┌──────────┐    ┌──────────┐                  │
│              │   ICMP   │    │   ARP    │                  │
│              │  (ping)  │    │(addr res)│                  │
│              └──────────┘    └──────────┘                  │
│                             │                               │
└─────────────────────────────┼───────────────────────────────┘
                              │
┌─────────────────────────────┼───────────────────────────────┐
│                    LINK LAYER                                │
│                             ▼                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                    Ethernet                             │ │
│  │            (frames, MAC addresses)                      │ │
│  └────────────────────────────────────────────────────────┘ │
│                             │                               │
└─────────────────────────────┼───────────────────────────────┘
                              ▼
                      Hardware (MAC)
```

### 6.2.2 TCP Protocol Fundamentals

```
TCP HEADER FORMAT (20+ bytes)
=============================

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│          Source Port          │       Destination Port        │
├───────────────────────────────────────────────────────────────┤
│                        Sequence Number                        │
├───────────────────────────────────────────────────────────────┤
│                    Acknowledgment Number                      │
├───────┬───────┬─┬─┬─┬─┬─┬─┬───────────────────────────────────┤
│ Data  │       │U│A│P│R│S│F│                                   │
│Offset │ Res.  │R│C│S│S│Y│I│            Window                 │
│       │       │G│K│H│T│N│N│                                   │
├───────────────────────────────────────────────────────────────┤
│           Checksum            │         Urgent Pointer        │
├───────────────────────────────────────────────────────────────┤
│                    Options (if Data Offset > 5)               │
├───────────────────────────────────────────────────────────────┤
│                             Data                              │
└───────────────────────────────────────────────────────────────┘

Flags:
  SYN - Synchronize sequence numbers (connection setup)
  ACK - Acknowledgment field is valid
  FIN - No more data from sender (connection teardown)
  RST - Reset connection
  PSH - Push data to application
  URG - Urgent pointer field is valid


TCP STATE MACHINE (Simplified)
==============================

Client Side:                           Server Side:

┌──────────┐                           ┌──────────┐
│  CLOSED  │                           │  CLOSED  │
└────┬─────┘                           └────┬─────┘
     │ connect()                            │ listen()
     ▼                                      ▼
┌──────────┐                           ┌──────────┐
│ SYN_SENT │ ─── SYN ──────────────▶   │  LISTEN  │
└────┬─────┘                           └────┬─────┘
     │                                      │ recv SYN
     │ ◀────────── SYN+ACK ────────────────┤
     │                                      ▼
     │                                 ┌──────────┐
     │                                 │ SYN_RCVD │
     │ recv SYN+ACK                    └────┬─────┘
     ▼                                      │
┌──────────┐                                │
│ESTABLISHED│ ─── ACK ─────────────────────▶│
└────┬─────┘                                ▼
     │                                 ┌──────────┐
     │ ◀═══════ DATA ═══════▶         │ESTABLISHED│
     │                                 └────┬─────┘
     │ close()                              │
     ▼                                      │
┌──────────┐                                │
│ FIN_WAIT │ ─── FIN ──────────────────────▶│
└────┬─────┘                                ▼
     │                                 ┌──────────┐
     │ ◀────────── ACK ────────────────│CLOSE_WAIT│
     │                                 └────┬─────┘
     │                                      │ close()
     │ ◀────────── FIN ────────────────────┤
     ▼                                      ▼
┌──────────┐                           ┌──────────┐
│TIME_WAIT │ ─── ACK ──────────────▶   │ LAST_ACK │
└────┬─────┘                           └────┬─────┘
     │ timeout                              │ recv ACK
     ▼                                      ▼
┌──────────┐                           ┌──────────┐
│  CLOSED  │                           │  CLOSED  │
└──────────┘                           └──────────┘


Three-Way Handshake:
  1. Client → Server: SYN (seq=x)
  2. Server → Client: SYN+ACK (seq=y, ack=x+1)
  3. Client → Server: ACK (ack=y+1)

Four-Way Teardown:
  1. A → B: FIN
  2. B → A: ACK
  3. B → A: FIN
  4. A → B: ACK
```

### 6.2.3 Implementation Checklist

#### File: `sw/kernel/net/tcp.c`

- [ ] **TCP Control Block (TCB)**
  ```c
  struct tcp_pcb {
      enum tcp_state state;
      uint32_t local_ip, remote_ip;
      uint16_t local_port, remote_port;
      
      // Sequence numbers
      uint32_t snd_una;    // oldest unacked
      uint32_t snd_nxt;    // next to send
      uint32_t rcv_nxt;    // next expected
      
      // Buffers
      struct ring_buffer send_buf;
      struct ring_buffer recv_buf;
      
      // Timers
      uint32_t rto;        // retransmit timeout
      uint32_t rtt;        // round-trip time estimate
      
      // Window
      uint16_t snd_wnd;    // send window
      uint16_t rcv_wnd;    // receive window
      
      // Retransmission
      struct tcp_segment *unacked;  // unacked segment list
  };
  ```

- [ ] **tcp_init()**
  - Initialize PCB table
  - Register with IP layer

- [ ] **tcp_new()**
  - Allocate new TCP PCB
  - Initialize state to CLOSED

- [ ] **tcp_bind()**
  - Assign local port
  - Check for conflicts

- [ ] **tcp_listen()**
  - Set state to LISTEN
  - Allocate accept queue

- [ ] **tcp_connect()**
  - Generate initial sequence number
  - Send SYN packet
  - Set state to SYN_SENT
  - Start timer

- [ ] **tcp_accept()**
  - Wait for connection in accept queue
  - Return new PCB for connected socket

- [ ] **tcp_send()**
  - Add data to send buffer
  - Trigger transmission

- [ ] **tcp_recv()**
  - Read from receive buffer
  - Update receive window

- [ ] **tcp_close()**
  - Send FIN
  - Set state appropriately
  - Wait for close sequence

- [ ] **tcp_input()**
  - Called by IP layer with incoming TCP segment
  - Find matching PCB
  - Process based on current state

- [ ] **tcp_output()**
  - Build TCP segment
  - Calculate checksum (including pseudo-header)
  - Send via IP

- [ ] **State handlers**
  - tcp_process_syn_sent()
  - tcp_process_syn_received()
  - tcp_process_established()
  - tcp_process_fin_wait()
  - tcp_process_close_wait()
  - tcp_process_last_ack()
  - tcp_process_time_wait()

- [ ] **Segment processing**
  - Check sequence number validity
  - Process ACK (advance snd_una)
  - Process data (add to recv buffer)
  - Process FIN

- [ ] **Retransmission**
  - Timer-based retransmit
  - Keep unacked segment queue
  - Exponential backoff

- [ ] **TCP checksum**
  - Include pseudo-header (src IP, dst IP, protocol, length)
  - 16-bit ones' complement sum

#### File: `sw/kernel/net/ip.c`

- [ ] **IP configuration**
  - Our IP address
  - Subnet mask
  - Gateway address

- [ ] **ip_input()**
  - Validate header checksum
  - Check destination IP
  - Dispatch to protocol handler (TCP, UDP, ICMP)

- [ ] **ip_output()**
  - Build IP header
  - Set protocol, addresses
  - Calculate header checksum
  - Route to interface

- [ ] **ip_checksum()**
  - 16-bit header checksum

- [ ] **Simple routing**
  - Same subnet: direct
  - Different subnet: via gateway

#### File: `sw/kernel/net/eth.c`

- [ ] **eth_input()**
  - Called by ethernet interrupt/poll
  - Parse ethernet header
  - Dispatch by ethertype (IP: 0x0800, ARP: 0x0806)

- [ ] **eth_output()**
  - Build ethernet header
  - Resolve destination MAC via ARP
  - Send via driver

#### File: `sw/kernel/net/arp.c`

- [ ] **ARP cache**
  - IP → MAC mapping table
  - Timeout entries

- [ ] **arp_request()**
  - Send ARP request for IP address

- [ ] **arp_input()**
  - Process ARP request: send reply
  - Process ARP reply: update cache

- [ ] **arp_resolve()**
  - Look up in cache
  - If not found, send request, wait

#### File: `sw/kernel/net/socket.c`

- [ ] **Socket API (syscall handlers)**

- [ ] **sys_socket()**
  - Create socket structure
  - domain: AF_INET
  - type: SOCK_STREAM (TCP), SOCK_DGRAM (UDP)
  - Return file descriptor

- [ ] **sys_bind()**
  - Associate socket with local address/port

- [ ] **sys_listen()**
  - Mark socket as passive (server)

- [ ] **sys_accept()**
  - Wait for and accept incoming connection
  - Return new socket fd for connection

- [ ] **sys_connect()**
  - Initiate connection to server

- [ ] **sys_send() / sys_sendto()**
  - Send data on socket

- [ ] **sys_recv() / sys_recvfrom()**
  - Receive data from socket

- [ ] **Socket structure**
  ```c
  struct socket {
      int type;              // SOCK_STREAM or SOCK_DGRAM
      int protocol;          // IPPROTO_TCP or IPPROTO_UDP
      union {
          struct tcp_pcb *tcp;
          struct udp_pcb *udp;
      };
      struct sockaddr_in local;
      struct sockaddr_in remote;
      int state;
  };
  ```

#### File: `sw/kernel/net/netif.c`

- [ ] **Network interface abstraction**
  - MAC address
  - IP address
  - Send/receive functions
  - Link state

- [ ] **netif_input()**
  - Entry point from driver

- [ ] **netif_output()**
  - Exit point to driver

#### Tests: `sw/kernel/test/test_tcp.c`

- [ ] **Test: three_way_handshake**
  - Verify SYN → SYN+ACK → ACK

- [ ] **Test: data_transfer**
  - Send data, verify received

- [ ] **Test: retransmission**
  - Drop packet, verify resent

- [ ] **Test: connection_close**
  - Verify FIN exchange

---

## 6.3 Project 2: telnetd

**Estimated Lines:** ~50 C

### 6.3.1 Telnet Overview

```
TELNET PROTOCOL
===============

Telnet is simple:
- TCP connection on port 23
- Characters sent in both directions
- Special escape sequences for terminal control

For our purposes:
- Accept connection
- Fork, exec shell with stdin/stdout connected to socket
- Multiple simultaneous connections (multiprocess)


TELNETD ARCHITECTURE
====================

┌─────────────────────────────────────────────────────────────┐
│                      telnetd                                 │
│                                                             │
│  Main Process:                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  1. socket()                                         │   │
│  │  2. bind(port 23)                                    │   │
│  │  3. listen()                                         │   │
│  │  4. while (1) {                                      │   │
│  │        client = accept()                             │   │
│  │        if (fork() == 0) {                            │   │
│  │            // Child: handle connection               │   │
│  │            dup2(client, stdin)                       │   │
│  │            dup2(client, stdout)                      │   │
│  │            dup2(client, stderr)                      │   │
│  │            exec("/bin/shell")                        │   │
│  │        }                                             │   │
│  │        close(client)  // Parent closes client fd     │   │
│  │     }                                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  Each connection gets own shell process:                    │
│                                                             │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                │
│  │ Client1 │    │ Client2 │    │ Client3 │                │
│  │ shell   │    │ shell   │    │ shell   │                │
│  └─────────┘    └─────────┘    └─────────┘                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.3.2 Implementation Checklist

#### File: `sw/user/telnetd.c`

- [ ] **main()**
  ```c
  int main() {
      int server = socket(AF_INET, SOCK_STREAM, 0);
      
      struct sockaddr_in addr;
      addr.sin_family = AF_INET;
      addr.sin_port = htons(23);
      addr.sin_addr.s_addr = INADDR_ANY;
      
      bind(server, (struct sockaddr*)&addr, sizeof(addr));
      listen(server, 5);
      
      while (1) {
          int client = accept(server, NULL, NULL);
          if (client < 0) continue;
          
          int pid = fork();
          if (pid == 0) {
              // Child process
              close(server);
              handle_client(client);
              exit(0);
          }
          close(client);  // Parent closes
      }
      return 0;
  }
  ```

- [ ] **handle_client()**
  - Redirect stdin/stdout/stderr to socket
  - Optionally send welcome message
  - Exec shell

- [ ] **Signal handling (optional)**
  - SIGCHLD handler to reap zombies
  - Or: ignore SIGCHLD

#### File: `sw/user/telnet.c` (client, optional)

- [ ] **main(argc, argv)**
  - Parse hostname/IP and port
  - Connect to server
  - Loop: read from socket → stdout, stdin → socket

---

## 6.4 Project 3: Dynamic Linker

**Estimated Lines:** ~300 C

### 6.4.1 Dynamic Linking Overview

```
DYNAMIC LINKING CONCEPTS
========================

Static Linking:
  - All code included in executable
  - Large executables
  - No sharing between programs

Dynamic Linking:
  - Shared libraries loaded at runtime
  - Smaller executables
  - Memory shared between processes
  - Can update library without relinking


SHARED LIBRARY FORMAT (ELF)
===========================

Executable contains:
  - .interp section: path to dynamic linker ("/lib/ld.so")
  - .dynamic section: library dependencies, symbol tables
  - PLT (Procedure Linkage Table): stubs for function calls
  - GOT (Global Offset Table): addresses resolved at runtime

Program Load Process:
  1. Kernel loads executable
  2. Kernel sees .interp, loads dynamic linker instead
  3. Dynamic linker:
     a. Maps executable into memory
     b. Reads .dynamic section
     c. Loads required shared libraries
     d. Resolves symbols, fills GOT
     e. Calls program entry point


PLT/GOT MECHANISM
=================

First call to printf():

┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│ User Code    │         │     PLT      │         │     GOT      │
│              │         │              │         │              │
│ call printf  │───────▶│ printf@plt:  │         │ printf@got:  │
│              │         │   j *GOT[n]  │───────▶│ [plt stub]   │──┐
│              │         │              │         │              │  │
│              │         │ resolve_stub:│◀────────────────────────┘
│              │         │   call linker│         │              │
│              │         │              │         │              │
└──────────────┘         └──────────────┘         └──────────────┘
                                │
                                ▼
                         ┌──────────────┐
                         │   Linker     │
                         │              │
                         │ 1. Find lib  │
                         │ 2. Find sym  │
                         │ 3. Update GOT│
                         │ 4. Jump to fn│
                         └──────────────┘

After first call:

┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│ User Code    │         │     PLT      │         │     GOT      │
│              │         │              │         │              │
│ call printf  │───────▶│ printf@plt:  │         │ printf@got:  │
│              │         │   j *GOT[n]  │───────▶│ [libc printf]│──┐
│              │         │              │         │              │  │
│              │         │              │         │              │  │
└──────────────┘         └──────────────┘         └──────────────┘  │
                                                                    │
                                                                    ▼
                                                         ┌──────────────┐
                                                         │ libc.so      │
                                                         │   printf()   │
                                                         └──────────────┘
```

### 6.4.2 Implementation Checklist

#### File: `sw/lib/ld.so.c` (Dynamic Linker)

- [ ] **Entry point**
  - Receive program info from kernel
  - Map executable (if not already mapped)
  - Process dynamic linking
  - Jump to program entry

- [ ] **elf_load_library()**
  - Find library file (search path)
  - Map library segments
  - Return library base address

- [ ] **process_dynamic()**
  - Parse .dynamic section
  - Find needed libraries (DT_NEEDED)
  - Find symbol tables (DT_SYMTAB, DT_STRTAB)
  - Find relocations (DT_REL, DT_RELA, DT_JMPREL)

- [ ] **load_dependencies()**
  - For each DT_NEEDED:
    - Load library recursively
    - Process its .dynamic section

- [ ] **resolve_symbol()**
  - Search symbol tables
  - Check each loaded library
  - Return symbol address

- [ ] **process_relocations()**
  - For each relocation entry:
    - Get symbol name
    - Resolve symbol address
    - Apply relocation to GOT or data

- [ ] **Relocation types (RISC-V)**
  - R_RISCV_RELATIVE: base + addend
  - R_RISCV_JUMP_SLOT: symbol address (PLT)
  - R_RISCV_GLOB_DAT: symbol address (data)
  - R_RISCV_32: absolute symbol address

- [ ] **Lazy binding (optional)**
  - Only resolve PLT entries on first call
  - PLT stub calls linker to resolve

- [ ] **dl_runtime_resolve()**
  - Called by PLT stub
  - Resolve symbol
  - Update GOT
  - Jump to resolved address

#### File: `sw/lib/libc.so` (Shared libc)

- [ ] **Build libc as shared library**
  - Position-independent code (-fPIC)
  - Shared library ELF format

- [ ] **Exports**
  - All standard functions
  - Global variables (__errno)

#### File: `tools/linker/linker.py` (Modifications)

- [ ] **Support shared libraries**
  - Emit PLT entries
  - Emit GOT entries
  - Emit .dynamic section
  - Set .interp to /lib/ld.so

- [ ] **-shared flag**
  - Generate shared library instead of executable

- [ ] **-fPIC flag handling**
  - Position-independent relocations

#### File: `sw/kernel/exec.c` (Modifications)

- [ ] **Detect dynamic executables**
  - Check for PT_INTERP
  - If present, load interpreter instead

- [ ] **Pass auxiliary vector**
  - AT_PHDR: program headers address
  - AT_PHNUM: number of program headers
  - AT_BASE: interpreter base (if present)
  - AT_ENTRY: program entry point

#### Tests

- [ ] **Test: simple_dynamic_link**
  - Build program using shared libc
  - Run and verify works

- [ ] **Test: multiple_libraries**
  - Program uses multiple shared libraries
  - Verify all loaded

- [ ] **Test: symbol_resolution**
  - Call functions from shared library
  - Verify correct functions called

---

## 6.5 Project 4: Text-Based Web Browser

**Estimated Lines:** ~500+ C

### 6.5.1 Browser Architecture

```
BROWSER COMPONENTS
==================

┌─────────────────────────────────────────────────────────────────┐
│                         centurion-browse                         │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    User Interface                        │   │
│  │  - Parse URL from command line or input                 │   │
│  │  - Display rendered content                             │   │
│  │  - Handle user navigation (links)                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    HTTP Client                           │   │
│  │  - Parse URL into host, port, path                      │   │
│  │  - DNS lookup (or use IP directly)                      │   │
│  │  - TCP connect to server                                │   │
│  │  - Send HTTP request                                    │   │
│  │  - Receive HTTP response                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    HTML Parser                           │   │
│  │  - Tokenize HTML                                        │   │
│  │  - Build simple DOM tree                                │   │
│  │  - Extract text content                                 │   │
│  │  - Identify links (<a href=...>)                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Text Renderer                          │   │
│  │  - Convert DOM to terminal output                       │   │
│  │  - Word wrapping                                        │   │
│  │  - ANSI formatting (bold, links)                        │   │
│  │  - Pagination                                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘


HTTP REQUEST/RESPONSE
=====================

Request:
  GET /index.html HTTP/1.0
  Host: example.com
  User-Agent: centurion/1.0
  Connection: close
  
  (blank line)

Response:
  HTTP/1.0 200 OK
  Content-Type: text/html
  Content-Length: 1234
  
  <!DOCTYPE html>
  <html>
  ...


HTML ELEMENTS TO SUPPORT
========================

Structure:    <html>, <head>, <body>, <title>
Headings:     <h1> - <h6>
Text:         <p>, <br>, <pre>
Formatting:   <b>, <i>, <u>, <em>, <strong>
Links:        <a href="...">
Lists:        <ul>, <ol>, <li>
Horizontal:   <hr>

Ignore (for simplicity):
  <script>, <style>, <img>, forms, tables
```

### 6.5.2 Implementation Checklist

#### File: `sw/user/browse.c` (Main)

- [ ] **main(argc, argv)**
  - Parse command line URL
  - Enter main loop
  - Handle user input

- [ ] **Main loop**
  - Fetch URL
  - Parse HTML
  - Render to terminal
  - Wait for input (q=quit, number=follow link, u=back)

- [ ] **History stack**
  - Push URL on navigation
  - Pop on back command

#### File: `sw/user/http.c`

- [ ] **URL structure**
  ```c
  struct url {
      char scheme[16];    // "http"
      char host[256];     // "example.com"
      uint16_t port;      // 80
      char path[1024];    // "/index.html"
  };
  ```

- [ ] **parse_url()**
  - Parse "http://host:port/path"
  - Default port 80
  - Default path "/"

- [ ] **http_get()**
  - Connect to server
  - Send GET request
  - Receive response
  - Return status and body

- [ ] **DNS lookup (simple)**
  - For now: require IP addresses
  - Or: hardcode a few common names
  - Full DNS: parse /etc/hosts file

- [ ] **http_send_request()**
  - Build request string
  - Send over socket

- [ ] **http_read_response()**
  - Read status line
  - Parse response code
  - Read headers
  - Read body (Content-Length or until close)

- [ ] **Handle redirects (optional)**
  - 301, 302 status
  - Follow Location header

#### File: `sw/user/html.c`

- [ ] **HTML tokenizer**
  - Token types: TAG_OPEN, TAG_CLOSE, TEXT, EOF
  - Handle < > escaping
  - Handle attributes

- [ ] **Token structure**
  ```c
  struct html_token {
      enum { TOK_OPEN, TOK_CLOSE, TOK_TEXT, TOK_EOF } type;
      char tag[32];           // tag name
      char text[4096];        // text content
      struct {
          char name[32];
          char value[256];
      } attrs[8];
      int attr_count;
  };
  ```

- [ ] **Simple DOM**
  ```c
  struct dom_node {
      enum { NODE_ELEMENT, NODE_TEXT } type;
      char tag[32];
      char text[4096];
      char href[256];         // for <a> tags
      struct dom_node *children;
      struct dom_node *next;
  };
  ```

- [ ] **parse_html()**
  - Tokenize input
  - Build DOM tree
  - Handle nesting

- [ ] **Entity decoding**
  - &amp; → &
  - &lt; → <
  - &gt; → >
  - &nbsp; → space
  - &quot; → "

#### File: `sw/user/render.c`

- [ ] **Terminal info**
  - Width (default 80)
  - Height (default 24)

- [ ] **ANSI escape codes**
  ```c
  #define ANSI_BOLD     "\033[1m"
  #define ANSI_RESET    "\033[0m"
  #define ANSI_UNDERLINE "\033[4m"
  #define ANSI_BLUE     "\033[34m"
  ```

- [ ] **render_dom()**
  - Walk DOM tree
  - Call element handlers
  - Output text

- [ ] **Word wrapping**
  - Track current column
  - Wrap at terminal width
  - Preserve indentation

- [ ] **Element handlers**
  - render_h1(): bold, newlines
  - render_p(): paragraph spacing
  - render_a(): number links, display text
  - render_li(): bullet point
  - render_pre(): preserve whitespace
  - render_br(): newline
  - render_hr(): horizontal line

- [ ] **Link collection**
  - Store links in array
  - Display as [1], [2], etc.
  - User enters number to follow

- [ ] **Page formatting**
  - Header with current URL
  - Footer with link legend
  - Scrolling support (if terminal allows)

#### File: `sw/user/browse_ui.c`

- [ ] **User input handling**
  - Read line from stdin
  - Parse command:
    - Number: follow link
    - 'q': quit
    - 'b' or 'u': back
    - URL: navigate to URL

- [ ] **Display link menu**
  - Show numbered list of links
  - Allow selection

- [ ] **Error display**
  - Connection errors
  - HTTP errors
  - Parse errors

#### Tests

- [ ] **Test: url_parsing**
  - Various URL formats
  - Edge cases

- [ ] **Test: http_request**
  - Connect to local test server
  - Verify request format

- [ ] **Test: html_parsing**
  - Parse sample HTML
  - Verify DOM structure

- [ ] **Test: rendering**
  - Render sample pages
  - Verify output format

---

## 6.6 Complete Example Session

```
BROWSER SESSION EXAMPLE
=======================

$ browse http://10.0.0.1/

===============================================================
                      Welcome to Centurion
===============================================================

CENTURION COMPUTING

This is a web page served from your custom operating system,
running on your custom CPU, built from scratch.

[1] About the Project
[2] Technical Details
[3] Source Code

---------------------------------------------------------------
[URL: http://10.0.0.1/]  [Links: 1-3]  [q]uit [b]ack [u]rl
> 2

===============================================================
                     Technical Details
===============================================================

HARDWARE

The Centurion system consists of:

  * RISC-V 32-bit processor (5-stage pipeline)
  * 1MB SRAM
  * UART for serial communication
  * Ethernet MAC for networking
  * SD card controller for storage

SOFTWARE

  * Custom C compiler (written in Haskell)
  * Custom linker (written in Python)
  * Unix-like operating system
  * TCP/IP network stack

[1] Back to Home

---------------------------------------------------------------
[URL: http://10.0.0.1/details.html]  [Links: 1]  [q]uit [b]ack
> b

(returns to home page)

> q
$
```

---

## 6.7 Concepts to Internalize

Before proceeding to Section 7:

1. **TCP reliability**: Sequence numbers, ACKs, retransmission
2. **TCP state machine**: Connection setup and teardown
3. **Socket abstraction**: File-like interface to network
4. **Dynamic linking**: Runtime symbol resolution
5. **Position-independent code**: Code that works at any address
6. **HTTP protocol**: Text-based request/response
7. **HTML structure**: Tags, attributes, nesting

---

## 6.8 Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| TCP sequence number wraparound | Use modular arithmetic |
| Forgetting network byte order | ntohs/htons, ntohl/htonl |
| HTTP header parsing edge cases | Handle missing Content-Length |
| HTML nesting errors | Build proper stack for parsing |
| ANSI codes in non-terminal | Detect terminal, disable colors |
| GOT not writable | Map with write permission |
