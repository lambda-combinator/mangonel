# Section 3: Processor — What is a Processor Anyway?

**Duration:** 3  
**Prerequisites:** Section 2 (UART working)  
**Hardware Language:** SystemVerilog  
**Software Languages:** Python (assembler), Assembly (bootrom)

---

## 3.1 Overview

This section builds a complete RISC-V processor:

1. **RISC-V Assembler** (Python, ~500 lines) — Translates assembly to machine code
2. **5-Stage RISC-V CPU** (SystemVerilog, ~1500 lines) — Classic pipelined processor
3. **Boot ROM** (Assembly, ~40 lines) — Initial code to load programs via UART

We implement RV32I — the base 32-bit integer instruction set. No floating point, no compressed instructions, no multiplication (yet).

---

## 3.2 RISC-V ISA Overview

### 3.2.1 Design Philosophy

RISC-V is:
- **Open**: Free to implement, no licensing fees
- **Simple**: Small base ISA, optional extensions
- **Regular**: Consistent instruction encoding
- **Modern**: Learned from 40 years of RISC experience

### 3.2.2 Registers

```
RISC-V INTEGER REGISTERS (RV32I)
================================

Register │ ABI Name │ Description           │ Saver
─────────┼──────────┼───────────────────────┼────────
x0       │ zero     │ Hard-wired zero       │ N/A
x1       │ ra       │ Return address        │ Caller
x2       │ sp       │ Stack pointer         │ Callee
x3       │ gp       │ Global pointer        │ --
x4       │ tp       │ Thread pointer        │ --
x5-x7    │ t0-t2    │ Temporaries           │ Caller
x8       │ s0/fp    │ Saved reg/Frame ptr   │ Callee
x9       │ s1       │ Saved register        │ Callee
x10-x11  │ a0-a1    │ Args / Return values  │ Caller
x12-x17  │ a2-a7    │ Arguments             │ Caller
x18-x27  │ s2-s11   │ Saved registers       │ Callee
x28-x31  │ t3-t6    │ Temporaries           │ Caller

Special:
- PC: Program Counter (not directly accessible)
- x0 always reads as 0, writes are discarded
```

### 3.2.3 Instruction Formats

```
RISC-V BASE INSTRUCTION FORMATS
===============================

All instructions are 32 bits, naturally aligned.

R-type (Register-Register):
┌─────────┬───────┬───────┬──────┬───────┬─────────┐
│  funct7 │  rs2  │  rs1  │funct3│  rd   │ opcode  │
│  [31:25]│[24:20]│[19:15]│[14:12]│[11:7]│  [6:0]  │
│  7 bits │5 bits │5 bits │3 bits│5 bits │ 7 bits  │
└─────────┴───────┴───────┴──────┴───────┴─────────┘
Example: ADD rd, rs1, rs2

I-type (Immediate):
┌─────────────────┬───────┬──────┬───────┬─────────┐
│    imm[11:0]    │  rs1  │funct3│  rd   │ opcode  │
│    [31:20]      │[19:15]│[14:12]│[11:7]│  [6:0]  │
│    12 bits      │5 bits │3 bits│5 bits │ 7 bits  │
└─────────────────┴───────┴──────┴───────┴─────────┘
Example: ADDI rd, rs1, imm; LW rd, offset(rs1)

S-type (Store):
┌─────────┬───────┬───────┬──────┬─────────┬─────────┐
│imm[11:5]│  rs2  │  rs1  │funct3│imm[4:0] │ opcode  │
│ [31:25] │[24:20]│[19:15]│[14:12]│ [11:7] │  [6:0]  │
│ 7 bits  │5 bits │5 bits │3 bits│ 5 bits  │ 7 bits  │
└─────────┴───────┴───────┴──────┴─────────┴─────────┘
Example: SW rs2, offset(rs1)

B-type (Branch):
┌────┬────────┬───────┬───────┬──────┬────────┬────┬─────────┐
│[12]│[10:5]  │  rs2  │  rs1  │funct3│ [4:1]  │[11]│ opcode  │
│ 1  │ 6 bits │5 bits │5 bits │3 bits│ 4 bits │ 1  │ 7 bits  │
└────┴────────┴───────┴───────┴──────┴────────┴────┴─────────┘
Example: BEQ rs1, rs2, offset (PC-relative, 13-bit signed, ×2)

U-type (Upper Immediate):
┌─────────────────────────┬───────┬─────────┐
│       imm[31:12]        │  rd   │ opcode  │
│        20 bits          │5 bits │ 7 bits  │
└─────────────────────────┴───────┴─────────┘
Example: LUI rd, imm; AUIPC rd, imm

J-type (Jump):
┌────┬──────────┬────┬──────────┬───────┬─────────┐
│[20]│ [10:1]   │[11]│ [19:12]  │  rd   │ opcode  │
│ 1  │ 10 bits  │ 1  │  8 bits  │5 bits │ 7 bits  │
└────┴──────────┴────┴──────────┴───────┴─────────┘
Example: JAL rd, offset (PC-relative, 21-bit signed, ×2)
```

### 3.2.4 RV32I Instruction List

```
RV32I BASE INSTRUCTIONS
=======================

ARITHMETIC:
  ADD   rd, rs1, rs2    # rd = rs1 + rs2
  SUB   rd, rs1, rs2    # rd = rs1 - rs2
  ADDI  rd, rs1, imm    # rd = rs1 + sext(imm)

LOGICAL:
  AND   rd, rs1, rs2    # rd = rs1 & rs2
  OR    rd, rs1, rs2    # rd = rs1 | rs2
  XOR   rd, rs1, rs2    # rd = rs1 ^ rs2
  ANDI  rd, rs1, imm    # rd = rs1 & sext(imm)
  ORI   rd, rs1, imm    # rd = rs1 | sext(imm)
  XORI  rd, rs1, imm    # rd = rs1 ^ sext(imm)

SHIFTS:
  SLL   rd, rs1, rs2    # rd = rs1 << rs2[4:0]
  SRL   rd, rs1, rs2    # rd = rs1 >> rs2[4:0] (logical)
  SRA   rd, rs1, rs2    # rd = rs1 >> rs2[4:0] (arithmetic)
  SLLI  rd, rs1, shamt  # rd = rs1 << shamt
  SRLI  rd, rs1, shamt  # rd = rs1 >> shamt (logical)
  SRAI  rd, rs1, shamt  # rd = rs1 >> shamt (arithmetic)

COMPARE:
  SLT   rd, rs1, rs2    # rd = (rs1 < rs2) ? 1 : 0 (signed)
  SLTU  rd, rs1, rs2    # rd = (rs1 < rs2) ? 1 : 0 (unsigned)
  SLTI  rd, rs1, imm    # rd = (rs1 < sext(imm)) ? 1 : 0
  SLTIU rd, rs1, imm    # rd = (rs1 < sext(imm)) ? 1 : 0 (unsigned cmp)

LOAD/STORE:
  LW    rd, off(rs1)    # rd = mem[rs1 + sext(off)]
  LH    rd, off(rs1)    # rd = sext(mem[rs1 + off][15:0])
  LHU   rd, off(rs1)    # rd = zext(mem[rs1 + off][15:0])
  LB    rd, off(rs1)    # rd = sext(mem[rs1 + off][7:0])
  LBU   rd, off(rs1)    # rd = zext(mem[rs1 + off][7:0])
  SW    rs2, off(rs1)   # mem[rs1 + sext(off)] = rs2
  SH    rs2, off(rs1)   # mem[rs1 + off][15:0] = rs2[15:0]
  SB    rs2, off(rs1)   # mem[rs1 + off][7:0] = rs2[7:0]

BRANCH:
  BEQ   rs1, rs2, off   # if (rs1 == rs2) PC += sext(off)
  BNE   rs1, rs2, off   # if (rs1 != rs2) PC += sext(off)
  BLT   rs1, rs2, off   # if (rs1 < rs2) PC += off (signed)
  BGE   rs1, rs2, off   # if (rs1 >= rs2) PC += off (signed)
  BLTU  rs1, rs2, off   # if (rs1 < rs2) PC += off (unsigned)
  BGEU  rs1, rs2, off   # if (rs1 >= rs2) PC += off (unsigned)

JUMP:
  JAL   rd, offset      # rd = PC+4; PC += sext(offset)
  JALR  rd, off(rs1)    # rd = PC+4; PC = (rs1 + sext(off)) & ~1

UPPER IMMEDIATE:
  LUI   rd, imm         # rd = imm << 12
  AUIPC rd, imm         # rd = PC + (imm << 12)

SYSTEM:
  ECALL                 # Environment call (syscall)
  EBREAK                # Debugger breakpoint
```

---

## 3.3 Project 1: RISC-V Assembler

**Estimated Lines:** ~500 Python

### 3.3.1 Assembler Architecture

```
ASSEMBLER PIPELINE
==================

┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   Source     │    │    Lexer     │    │   Parser     │    │   Encoder    │
│   .s file    │───▶│              │───▶│              │───▶│              │
│              │    │  Tokenize    │    │  Parse AST   │    │ Gen machine  │
│              │    │              │    │              │    │    code      │
└──────────────┘    └──────────────┘    └──────────────┘    └──────────────┘
                                                                   │
                                               ┌───────────────────┘
                                               ▼
                    ┌──────────────┐    ┌──────────────┐
                    │   Output     │◀───│   Linker     │
                    │  .bin/.elf   │    │  (Phase 2)   │
                    │              │    │              │
                    └──────────────┘    └──────────────┘

Pass 1: Collect labels, compute addresses
Pass 2: Resolve labels, encode instructions
```

### 3.3.2 Implementation Checklist

#### File: `tools/assembler/riscv_asm.py` (Main)

- [ ] **Command-line interface**
  - Input file argument
  - Output file argument
  - Output format flag (binary, hex, elf)
  - Base address option

- [ ] **Main assemble() function**
  - Read source file
  - Call lexer
  - Call parser (pass 1)
  - Call encoder (pass 2)
  - Write output

#### File: `tools/assembler/lexer.py`

- [ ] **Token class/namedtuple**
  - Fields: type, value, line_num, column

- [ ] **Token types enum**
  - INSTRUCTION, REGISTER, IMMEDIATE, LABEL, LABEL_REF
  - DIRECTIVE, STRING, COMMA, LPAREN, RPAREN, COLON, NEWLINE, EOF

- [ ] **Lexer class**
  - Input: source string
  - Output: list of tokens

- [ ] **tokenize() method**
  - Skip whitespace and comments (# to end of line)
  - Recognize instruction mnemonics
  - Recognize register names (x0-x31 and ABI names)
  - Recognize immediates (decimal, hex 0x, binary 0b)
  - Recognize labels (identifier followed by colon)
  - Recognize label references (identifier)
  - Recognize directives (.text, .data, .word, .byte, .ascii, .align)
  - Handle string literals

- [ ] **Error reporting**
  - Line number and column
  - Helpful error message

#### File: `tools/assembler/parser.py`

- [ ] **AST node classes**
  - Instruction: mnemonic, operands, address
  - Label: name, address
  - Directive: name, arguments
  - DataWord/DataByte: value, address

- [ ] **Parser class**
  - Input: token list
  - Output: AST + symbol table

- [ ] **First pass: collect_labels()**
  - Iterate through tokens
  - Track current address
  - Record label addresses in symbol table
  - Handle alignment directives

- [ ] **parse_instruction()**
  - Match instruction mnemonic
  - Parse operands based on instruction format
  - Return Instruction AST node

- [ ] **parse_operand()**
  - Register: return register number (0-31)
  - Immediate: return integer value
  - Label reference: return label name (resolved later)
  - Memory operand: parse offset(reg) syntax

- [ ] **parse_directive()**
  - .text: switch to text section
  - .data: switch to data section
  - .word: emit 32-bit value
  - .half: emit 16-bit value
  - .byte: emit 8-bit value
  - .ascii/.asciz: emit string bytes
  - .align: align address
  - .global: mark symbol as global
  - .equ: define constant

#### File: `tools/assembler/encoder.py`

- [ ] **Encoder class**
  - Input: AST, symbol table
  - Output: byte array

- [ ] **Instruction encoding tables**
  - Opcode for each instruction
  - funct3 for each instruction
  - funct7 where applicable
  - Instruction format (R, I, S, B, U, J)

- [ ] **encode_r_type()**
  - Pack: funct7, rs2, rs1, funct3, rd, opcode
  - Return 4-byte little-endian

- [ ] **encode_i_type()**
  - Pack: imm[11:0], rs1, funct3, rd, opcode
  - Sign extend immediate if negative

- [ ] **encode_s_type()**
  - Split immediate: imm[11:5], imm[4:0]
  - Pack appropriately

- [ ] **encode_b_type()**
  - Calculate PC-relative offset
  - Check offset fits in 13 bits (signed, ×2)
  - Scramble immediate bits per B-format

- [ ] **encode_u_type()**
  - Pack: imm[31:12], rd, opcode

- [ ] **encode_j_type()**
  - Calculate PC-relative offset
  - Check offset fits in 21 bits (signed, ×2)
  - Scramble immediate bits per J-format

- [ ] **Pseudo-instruction expansion**
  - `li rd, imm` → LUI + ADDI (if imm > 12 bits)
  - `la rd, label` → AUIPC + ADDI
  - `mv rd, rs` → ADDI rd, rs, 0
  - `nop` → ADDI x0, x0, 0
  - `j offset` → JAL x0, offset
  - `jr rs` → JALR x0, rs, 0
  - `ret` → JALR x0, ra, 0
  - `call label` → AUIPC + JALR
  - `tail label` → AUIPC + JALR (without link)
  - `beqz rs, off` → BEQ rs, x0, off
  - `bnez rs, off` → BNE rs, x0, off

- [ ] **Label resolution**
  - Look up label in symbol table
  - Calculate offset relative to current PC
  - Error if label undefined

#### File: `tools/assembler/output.py`

- [ ] **write_binary()**
  - Raw bytes, starting at base address
  - Pad with zeros if gaps in address space

- [ ] **write_hex()**
  - Intel HEX or simple hex dump
  - For loading into simulation memory

- [ ] **write_verilog_mem()**
  - `$readmemh` compatible format
  - Address: data pairs

#### File: `tools/assembler/test_assembler.py`

- [ ] **Test: arithmetic_instructions**
  - Assemble ADD, SUB, ADDI
  - Verify encoding matches reference

- [ ] **Test: logical_instructions**
  - AND, OR, XOR, ANDI, ORI, XORI

- [ ] **Test: shift_instructions**
  - SLL, SRL, SRA, SLLI, SRLI, SRAI

- [ ] **Test: load_store_instructions**
  - LW, SW, LH, LB, LHU, LBU, SH, SB

- [ ] **Test: branch_instructions**
  - BEQ, BNE, BLT, BGE, BLTU, BGEU
  - Forward and backward branches
  - Verify offsets

- [ ] **Test: jump_instructions**
  - JAL, JALR with various offsets

- [ ] **Test: upper_immediate**
  - LUI, AUIPC

- [ ] **Test: pseudo_instructions**
  - li, la, mv, nop, j, ret, call

- [ ] **Test: labels**
  - Forward reference
  - Backward reference
  - Label arithmetic

- [ ] **Test: directives**
  - .word, .byte, .align, .ascii

- [ ] **Test: error_handling**
  - Undefined label
  - Invalid register
  - Offset out of range
  - Syntax errors

---

## 3.4 Project 2: 5-Stage RISC-V CPU with Caches

**Estimated Lines:** ~2500 SystemVerilog

### 3.4.1 Overview

This project implements a complete 5-stage pipelined RISC-V core (RV32I) with separate instruction and data caches. The design is optimized for educational purposes and research on cache behavior, featuring straightforward hazard detection, forwarding logic, and direct-mapped caches.

**Key Specifications:**
- **Architecture**: 5-stage pipeline (Fetch → Decode → Execute → Memory → Write-back)
- **ISA**: RISC-V RV32I (32-bit, base integer instruction set)
- **Registers**: 32 × 32-bit general-purpose registers (x0-x31)
- **Instruction Cache**: 16 KB, direct-mapped, 64-byte lines
- **Data Cache**: 16 KB, direct-mapped, 64-byte lines
- **Main Memory**: 1 MB, with configurable access latency

### 3.4.2 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    RISC-V Core with Caches                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                         FETCH STAGE                              │   │
│  │  ┌─────────────┐              ┌──────────┐                       │   │
│  │  │   Program   │◄─────┬──────►│ I-Cache  │                       │   │
│  │  │  Counter    │      │       │ (16KB)   │                       │   │
│  │  │   (PC)      │      │       │ Direct   │                       │   │
│  │  └─────────────┘      │       │ Mapped   │                       │   │
│  │                       │       └──────────┘                       │   │
│  │                       │              │                           │   │
│  │                       │              │ Cache Miss                │   │
│  │                       │              ▼                           │   │
│  │                       │       ┌──────────┐                       │   │
│  │                       └──────►│  Memory  │                       │   │
│  │                               │Controller│◄──► Main Memory       │   │
│  │                               │  (AXI)   │     (1 MB)            │   │
│  │                               └──────────┘                       │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│           │ [Instruction]                                               │
│           ▼                                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                      DECODE STAGE                                │   │
│  │  ┌───────────────────────────────────────────────────────────┐   │   │
│  │  │      Instruction Decoder                                  │   │   │
│  │  │  ┌───────┬────────────┬──────────┬─────────────┐          │   │   │
│  │  │  │Opcode │ Register   │ Immediate│  Control    │          │   │   │
│  │  │  │Parser │ Fields     │ Extract  │  Signals    │          │   │   │
│  │  │  │(7-bit)│ (rs1, rs2, │ (I/S/B/  │ Generator   │          │   │   │
│  │  │  │       │  rd)       │  U/J)    │             │          │   │   │
│  │  │  └───────┴────────────┴──────────┴─────────────┘          │   │   │
│  │  └───────────────────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│           │ [Opcode, RS1/RS2, RD, Immediate, Ctrl]                      │
│           ▼                                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    REGISTER FILE                                 │   │
│  │  ┌──────────────────────────────────────────────────────────┐    │   │
│  │  │                    32 × 32-bit Registers                 │    │   │
│  │  │  x0=0  x1(ra)  x2(sp)  x3(gp)  ... x31                   │    │   │
│  │  │  Read Port 1  ◄─ RS1  (from Decode)                      │    │   │
│  │  │  Read Port 2  ◄─ RS2  (from Decode)                      │    │   │
│  │  │  Write Port   ◄─ WD   (from Write-back)                  │    │   │
│  │  └──────────────────────────────────────────────────────────┘    │   │
│  └───────────────────┬──────────────┬───────────────────────────────┘   │
│                      │ [RD1]   [RD2]│                                   │
│           ┌──────────┘              └──────────┐                        │
│           ▼                                     ▼                       │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    EXECUTE STAGE                                 │   │
│  │  ┌──────────────────────────────────────────────────────────┐    │   │
│  │  │         Forwarding Muxes (Hazard Resolution)             │    │   │
│  │  │  Select: ID/EX.data | EX/MEM.result | MEM/WB.result      │    │   │
│  │  └──────────────────────────────────────────────────────────┘    │   │
│  │           │                                     │                │   │
│  │           ▼                                     ▼                │   │
│  │  ┌──────────────────────────────────────────────────────────┐    │   │
│  │  │                        ALU                               │    │   │
│  │  │  ┌─────────┬────────┬─────────┬──────┬────────┐          │    │   │
│  │  │  │ Adder   │ Shift  │ Logic   │ Comp │ Branch │          │    │   │
│  │  │  │ (Add/   │ (SLL,  │ (AND,   │ (SLT,│Condition          │    │   │
│  │  │  │  Sub)   │  SRL,  │  OR,    │ SLTU)│ (BEQ,  │          │    │   │
│  │  │  │         │  SRA)  │  XOR)   │      │ BNE,   │          │    │   │
│  │  │  │         │        │         │      │ BLT...)│          │    │   │
│  │  │  └─────────┴────────┴─────────┴──────┴────────┘          │    │   │
│  │  │         │                              │                 │    │   │
│  │  │         │ ALU Result                   │ Branch Taken    │    │   │
│  │  └─────────┼──────────────────────────────┼─────────────────┘    │   │
│  │            │                              │                      │   │
│  │            │                              ▼                      │   │
│  │            │                    ┌──────────────────┐             │   │
│  │            │                    │ Branch Target    │             │   │
│  │            │                    │ Calculation      │             │   │
│  │            │                    │ PC + imm         │             │   │
│  │            │                    └──────────────────┘             │   │
│  └────────────┼─────────────────────────────────────────────────────┘   │
│               │ [ALU Result, Branch Taken, Branch Target]               │
│               ▼                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    MEMORY STAGE                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐  │   │
│  │  │              Data Cache (16KB)                             │  │   │
│  │  │  Direct-mapped, 64-byte lines                              │  │   │
│  │  │  ┌──────────────────────────────────────────────────────┐  │  │   │
│  │  │  │  Cache Controller                                    │  │  │   │
│  │  │  │  ┌────────┬─────────────┬──────────┬──────────┐      │  │  │   │
│  │  │  │  │ Tag    │ Valid Bit   │ Data     │ Dirty    │      │  │  │   │
│  │  │  │  │ Check  │ Check       │ Array    │ Bit      │      │  │  │   │
│  │  │  │  │        │             │ (256×64B)│ (Write-  │      │  │  │   │
│  │  │  │  │        │             │          │  back)   │      │  │  │   │
│  │  │  │  └────────┴─────────────┴──────────┴──────────┘      │  │  │   │
│  │  │  │                                                      │  │  │   │
│  │  │  │  Hit: Return data in 1 cycle                         │  │  │   │
│  │  │  │  Miss: Fetch line from memory (multi-cycle)          │  │  │   │
│  │  │  └──────────────────────────────────────────────────────┘  │  │   │
│  │  │                      │ Cache Miss                          │  │   │
│  │  │                      ▼                                     │  │   │
│  │  │          ┌──────────────────────┐                          │  │   │
│  │  │          │  Memory Controller   │                          │  │   │
│  │  │          │  ┌────────────────┐  │                          │  │   │
│  │  │          │  │ AXI Master     │  │                          │  │   │
│  │  │          │  │ Interface      │  │                          │  │   │
│  │  │          │  └────────────────┘  │                          │  │   │
│  │  │          │        ▼             │                          │  │   │
│  │  │          │  Main Memory (1MB)   │                          │  │   │
│  │  │          │  32-bit wide         │                          │  │   │
│  │  │          └──────────────────────┘                          │  │   │
│  │  └────────────────────────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│           │ [Memory Data or Forwarded ALU Result]                       │
│           ▼                                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                   WRITE-BACK STAGE                               │   │
│  │  ┌──────────────────────────────────────────────────────────┐    │   │
│  │  │  Result Multiplexer: Choose write-back source            │    │   │
│  │  │  ┌─────────┬──────────┬─────────────┬──────────┐         │    │   │
│  │  │  │  ALU    │ Memory   │   PC+4      │ Upper    │         │    │   │
│  │  │  │ Result  │ Data     │ (for JAL/   │ Imm      │         │    │   │
│  │  │  │         │ (Load)   │  JALR)      │ (LUI)    │         │    │   │
│  │  │  └─────────┴──────────┴─────────────┴──────────┘         │    │   │
│  │  └──────────────────────────────────────────────────────────┘    │   │
│  │                       │                                          │   │
│  │                       └──► Register File Write Port              │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │        HAZARD DETECTION & FORWARDING UNIT                        │   │
│  │                                                                  │   │
│  │  1. Data Forwarding (EX/MEM → EX, MEM/WB → EX)                   │   │
│  │     If (RS1 == EX/MEM.RD) forward EX/MEM.result to ALU A         │   │
│  │     If (RS2 == EX/MEM.RD) forward EX/MEM.result to ALU B         │   │
│  │     If (RS1 == MEM/WB.RD) forward MEM/WB.result to ALU A         │   │
│  │     If (RS2 == MEM/WB.RD) forward MEM/WB.result to ALU B         │   │
│  │                                                                  │   │
│  │  2. Load-Use Hazard Detection                                    │   │
│  │     If (ID/EX.MemRead && (ID/EX.RD == IF/ID.RS1 ||               │   │
│  │                           ID/EX.RD == IF/ID.RS2))                │   │
│  │        → Stall pipeline for 1 cycle                              │   │
│  │                                                                  │   │
│  │  3. Branch Hazard (Control Hazard)                               │   │
│  │     Predict not-taken (fetch PC+4)                               │   │
│  │     If branch taken in EX:                                       │   │
│  │        → Flush IF/ID and ID/EX stages                            │   │
│  │        → Redirect PC to branch target                            │   │
│  │                                                                  │   │
│  │  4. Cache Miss Stall                                             │   │
│  │     If I-Cache miss: Stall IF until line fetched                 │   │
│  │     If D-Cache miss: Stall MEM until line fetched                │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.4.3 Data Flow Summary

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Pipeline Data Flow                          │
└─────────────────────────────────────────────────────────────────────┘

   PC ──► I-Cache ──► Fetch ──► [Instr] ──► IF/ID Register
                │                              │
         (miss)│                               ▼
                │                          Decode ───────┐
                ▼                              │         │
          Memory Controller                    │         │
                ▲                               ▼        │
                │                     Register File Read │
                │                              │         │
                │                              ▼         │
                │                        ID/EX Register  │
                │                              │         │
                │                              ▼         │
                │                          Execute ◄─────┘
                │                         (with Forwarding)
                │                              │
                │                              │ ALU Result
                │                              │ Branch Target
                │                              ▼
                │                        EX/MEM Register
                │                              │
                │                              ▼
                │                          Memory ◄───► D-Cache ◄─┐
                │                              │                  │
                └──────────────────────────────┼──────────────────┘
                                               │ (miss)
                                               ▼
                                         MEM/WB Register
                                               │
                                               ▼
                                           WriteBack
                                               │
                                               ▼
                                    Register File Write Port
                                               │
                                               │
         ┌─────────────────────────────────────┘
         │ Forwarding paths back to Execute stage
         └────────────────────────────────────────►
```

### 3.4.4 Cache Architecture

```
INSTRUCTION CACHE (I-CACHE)
===========================

Size: 16 KB
Organization: Direct-mapped
Line size: 64 bytes (16 words)
Number of lines: 256 (16 KB / 64 B)

Address breakdown (32-bit address):
┌─────────────┬──────────┬────────────┐
│ Tag         │  Index   │   Offset   │
│ [31:14]     │  [13:6]  │   [5:0]    │
│ 18 bits     │  8 bits  │   6 bits   │
└─────────────┴──────────┴────────────┘

Cache line structure:
┌───────┬───────────┬──────────────────────────────────────┐
│ Valid │ Tag (18)  │ Data (64 bytes = 16 words)           │
│ 1 bit │ 18 bits   │ 512 bits                             │
└───────┴───────────┴──────────────────────────────────────┘

Operation:
1. Extract index from address[13:6]
2. Read cache line at index
3. Check valid bit and compare tag
4. If hit: Return word at offset address[5:2]
5. If miss: Fetch line from memory, update cache


DATA CACHE (D-CACHE)
====================

Size: 16 KB
Organization: Direct-mapped
Line size: 64 bytes (16 words)
Number of lines: 256
Write policy: Write-back with dirty bit

Address breakdown (same as I-Cache):
┌─────────────┬──────────┬────────────┐
│ Tag         │  Index   │   Offset   │
│ [31:14]     │  [13:6]  │   [5:0]    │
│ 18 bits     │  8 bits  │   6 bits   │
└─────────────┴──────────┴────────────┘

Cache line structure:
┌───────┬───────┬───────────┬──────────────────────────────┐
│ Valid │ Dirty │ Tag (18)  │ Data (64 bytes)              │
│ 1 bit │ 1 bit │ 18 bits   │ 512 bits                     │
└───────┴───────┴───────────┴──────────────────────────────┘

Write-back operation:
- On write hit: Update data, set dirty bit
- On eviction with dirty bit: Write line back to memory
- On clean eviction: Simply discard

Load operation:
1. Check cache for hit
2. If hit: Return data immediately
3. If miss: 
   a. If evicting dirty line, write back first
   b. Fetch new line from memory
   c. Update cache
   d. Return requested data

Store operation:
1. Check cache for hit
2. If hit: Update data, set dirty
3. If miss (write-allocate):
   a. Fetch line from memory
   b. Update word in line
   c. Set dirty bit


MEMORY CONTROLLER
=================

Interfaces:
- I-Cache miss request port
- D-Cache miss request port
- AXI master to main memory

Arbitration:
- Priority: D-Cache > I-Cache (data access more critical)
- Burst transfers for cache line fills (16 word burst)

Memory layout (1 MB):
┌─────────────────────────────────────────────────┐
│ 0x00000000 - 0x0000FFFF: Boot ROM (64 KB)       │
│ 0x00010000 - 0x0007FFFF: Program (448 KB)       │
│ 0x00080000 - 0x000FFFFF: Data (512 KB)          │
└─────────────────────────────────────────────────┘
```

### 3.4.5 Pipeline Hazards & Solutions

```
COMPREHENSIVE HAZARD HANDLING
==============================

1. DATA HAZARDS (RAW - Read After Write)
────────────────────────────────────────

Problem: Instruction needs data not yet written back

  ADD x1, x2, x3    [IF][ID][EX][MEM][WB]
  SUB x4, x1, x5       [IF][ID][EX][MEM][WB]   ← needs x1 from ADD
                            ↑
                        x1 not ready yet!

Solution: FORWARDING (ALU-to-ALU bypass)
  ADD x1, x2, x3    [IF][ID][EX][MEM][WB]
  SUB x4, x1, x5       [IF][ID][EX][MEM][WB]   ← forward from EX/MEM
                            ↑─────────┘
                     (NO stall, data bypassed)

Forwarding logic:
  Priority 1 (most recent): EX/MEM.result → EX stage ALU inputs
  Priority 2 (older):        MEM/WB.result → EX stage ALU inputs

Implementation:
  if (EX/MEM.RegWrite && EX/MEM.RD != 0 && EX/MEM.RD == ID/EX.RS1)
    ForwardA = 2'b10;  // Forward from EX/MEM
  else if (MEM/WB.RegWrite && MEM/WB.RD != 0 && MEM/WB.RD == ID/EX.RS1)
    ForwardA = 2'b01;  // Forward from MEM/WB
  else
    ForwardA = 2'b00;  // No forwarding

  // Same logic for RS2 → ForwardB


2. LOAD-USE HAZARD (Special RAW Case)
──────────────────────────────────────

Problem: Load followed immediately by dependent instruction

  LW  x1, 0(x2)     [IF][ID][EX][MEM][WB]
  ADD x3, x1, x4       [IF][ID][EX][MEM][WB]   ← needs x1
                            ↑
                    Data ready here (MEM stage)
                    But ADD needs it in EX (too early!)

Cannot forward memory data to EX in same cycle (data not ready yet)

Solution: STALL for 1 cycle
  LW  x1, 0(x2)     [IF][ID][EX][MEM][WB]
  ADD x3, x1, x4       [IF][ID][──][EX][MEM][WB]   ← stall, then forward
                            (bubble inserted)
                                  ↑
                    Forward from MEM/WB next cycle

Detection:
  if (ID/EX.MemRead && 
      (ID/EX.RD == IF/ID.RS1 || ID/EX.RD == IF/ID.RS2))
    Stall = 1;
    // Keep IF/ID frozen, insert NOP in ID/EX

Performance: 1-cycle penalty per load-use hazard


3. CONTROL HAZARDS (Branches)
──────────────────────────────

Problem: Don't know next PC until branch resolved in EX stage

  BEQ x1, x2, label [IF][ID][EX][MEM][WB]
  instr2              [IF][ID][??][??][??]   ← might be wrong path
  instr3                 [IF][??][??][??][??]

Solution: PREDICT NOT-TAKEN + FLUSH on misprediction

Default: Always fetch PC+4 (predict branch not taken)

If branch actually taken (detected in EX):
  - Flush IF/ID and ID/EX stages (convert to NOPs)
  - Redirect PC to branch target
  - Cost: 2-cycle penalty

Example (branch taken):
  BEQ x1,x2,100   [IF][ID][EX][MEM][WB]
  ADD x3,x4,x5       [IF][ID][flush]        ← discarded
  SUB x6,x7,x8          [IF][flush]         ← discarded
  target: ...              [IF][ID][EX]     ← correct path

Branch resolution in EX:
  - Compare operands (with forwarding if needed)
  - Calculate target: PC + sign_extend(imm_B)
  - Set branch_taken signal
  - Provide target to PC mux

Alternative (future enhancement): 2-bit branch predictor
  - Predict based on history
  - Lower misprediction rate
  - Requires branch target buffer (BTB)


4. CACHE MISS STALLS
────────────────────

Problem: Cache miss requires multiple cycles to fetch data from memory

I-Cache Miss (Fetch stage):
  - Stall entire pipeline until instruction line fetched
  - Typical: 10-20 cycles for memory access
  - Keep all pipeline stages frozen

  Cycle 0:  FETCH (miss) │ ...normal pipeline...
  Cycle 1:  FETCH (stall)│ ...all stages stalled...
  Cycle 2:  FETCH (stall)│ ...all stages stalled...
  ...
  Cycle N:  FETCH (hit)  │ ...pipeline resumes...

D-Cache Miss (Memory stage):
  - Stall pipeline from IF through MEM
  - Allow WB to complete (for older instructions)
  - Typical: 10-20 cycles

  LW x1, 0(x2)  [IF][ID][EX][MEM──────][WB]
  ADD x3,x1,x4     [IF][ID][EX][stall]
  ...                 [IF][ID][stall]
                         [IF][stall]

Write-back on dirty eviction:
  - If evicting dirty line, write back first
  - Additional ~10-20 cycles
  - Total miss penalty: 20-40 cycles for dirty eviction

Cache miss handling:
  1. Detect miss (tag mismatch or invalid)
  2. Assert stall signal to hazard unit
  3. Issue memory request to controller
  4. Wait for memory response (burst transfer)
  5. Update cache line
  6. Retry access (will hit)
  7. Deassert stall, resume pipeline


FORWARDING PATHS SUMMARY
=========================

From EX/MEM to EX:
  EX/MEM.ALU_result → ALU operand A mux (if RD matches RS1)
  EX/MEM.ALU_result → ALU operand B mux (if RD matches RS2)
  EX/MEM.ALU_result → Store data (if RD matches RS2 on store)

From MEM/WB to EX:
  MEM/WB.Result → ALU operand A mux (if RD matches RS1, lower priority)
  MEM/WB.Result → ALU operand B mux (if RD matches RS2, lower priority)

Note: Store instructions need RS2 forwarding even though RS2 is not
      an ALU input (it's the data to store)

Forwarding mux select:
  00: Use value from ID/EX register (no forwarding)
  01: Forward from MEM/WB (older result)
  10: Forward from EX/MEM (newer result, takes priority)
  11: (unused)
```

### 3.4.6 Implementation Checklist

#### File: `rtl/core/pkg_riscv.sv` (Package)

- [ ] **Opcode definitions**
  - Define enum for all RV32I opcodes (LUI, AUIPC, JAL, JALR, BRANCH, LOAD, STORE, IMM, REG, SYSTEM)
  - Use 7-bit logic values matching RISC-V specification
  - Reference: See section 3.2.3 for opcode values

- [ ] **Funct3 definitions**
  - Define constants or enum for funct3 field values
  - Group by instruction type: Branch, Load, Store, ALU operations
  - Cover all variants (signed/unsigned, byte/half/word)

- [ ] **ALU operation codes**
  - Define enum for internal ALU operations
  - Include: ADD, SUB, logical ops (AND, OR, XOR)
  - Include: shifts (SLL, SRL, SRA)
  - Include: comparisons (SLT, SLTU)
  - Include: pass-through operations for special cases

- [ ] **Immediate type enum**
  - Define enum for 5 immediate formats (I, S, B, U, J)
  - Used by immediate generator to select correct extraction

- [ ] **Control signal struct**
  - Create packed struct containing all pipeline control signals
  - Include: register write enable, memory read/write
  - Include: branch/jump flags, ALU source selects
  - Include: writeback source mux select
  - Include: ALU operation, immediate type, funct3/funct7 passthrough

- [ ] **Cache parameters**
  - I-Cache: 16 KB total size, 64-byte lines, 256 lines
  - Calculate index bits (8), offset bits (6), tag bits (18)
  - D-Cache: Same configuration as I-Cache
  - Memory: 1 MB total, calculate address width needed
  - Define as localparams for easy configuration

- [ ] **Pipeline register structs**
  - IF/ID register: PC, instruction word, valid bit
  - ID/EX register: PC, register data (rs1, rs2), immediate, register addresses, control signals, valid
  - EX/MEM register: ALU result, store data, destination register, control signals, valid
  - MEM/WB register: ALU result, memory data, destination register, writeback control, valid
  - Use packed structs for clean pipeline register transfers

#### File: `rtl/core/fetch.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, stall, flush, branch_taken, branch_target
  - Outputs: pc, instruction, valid, icache_stall
  - Cache interface: icache_req, icache_addr, icache_data, icache_ready

- [ ] **PC register**
  - Reset to configurable start address (default: 0x00000000)
  - Update every cycle based on stall, flush, and branch signals
  - Hold value when stalled or cache miss
  - Load branch target when branch taken

- [ ] **PC mux**
  - Select next PC value based on control signals
  - Priority order: branch target, sequential (PC+4), hold
  - Consider all hazard and cache miss conditions

- [ ] **I-Cache instantiation**
  - Connect: address ← PC
  - Connect: req ← !stall && valid
  - Receive: data (instruction), ready (hit/miss), stall

- [ ] **Instruction output**
  - Direct connection from cache data output
  - Valid bit: set if cache hit and no flush

- [ ] **IF/ID pipeline register**
  - Clock enable: !stall && !icache_stall
  - Async reset or synchronous clear on flush
  - Registered signals:
    - pc_reg ← PC
    - instruction_reg ← instruction
    - valid_reg ← valid && !flush

- [ ] **Stall generation**
  - icache_stall ← !icache_ready (cache miss)
  - Propagate to hazard unit

#### File: `rtl/core/icache.sv` (Instruction Cache)

- [ ] **Module ports**
  - Inputs: clk, rst_n, req, addr[31:0]
  - Outputs: data[31:0], ready, stall
  - Memory controller interface: mem_req, mem_addr, mem_data, mem_ready

- [ ] **Address breakdown**
  - tag = addr[31:14]      (18 bits)
  - index = addr[13:6]     (8 bits)
  - offset = addr[5:0]     (6 bits, byte address)
  - word_offset = addr[5:2] (4 bits, word select within line)

- [ ] **Cache storage arrays**
  - valid_array: reg [255:0] (256 valid bits, one per line)
  - tag_array: reg [17:0] tags [0:255] (256 × 18-bit tags)
  - data_array: reg [31:0] data [0:255][0:15] (256 lines × 16 words)
    - Alternative: reg [511:0] data [0:255], extract word by offset

- [ ] **Cache lookup logic (combinational)**
  - On request:
    1. Extract index from address
    2. Read valid bit: valid = valid_array[index]
    3. Read stored tag: stored_tag = tag_array[index]
    4. Compare: hit = valid && (stored_tag == tag)
    5. If hit: Extract word from data_array[index][word_offset]

- [ ] **Cache miss handling (FSM)**
  - States: IDLE, MISS_REQ, MISS_WAIT, MISS_FILL
  - IDLE: Wait for request
    - If req && hit: Serve immediately (ready=1, stall=0)
    - If req && !hit: Go to MISS_REQ
  - MISS_REQ: Assert memory request for full line
    - mem_req ← 1
    - mem_addr ← {addr[31:6], 6'b0} (line-aligned)
    - Go to MISS_WAIT
  - MISS_WAIT: Wait for memory controller
    - If mem_ready: Start receiving line data
    - Burst transfer: 16 words × 32 bits
    - Go to MISS_FILL
  - MISS_FILL: Write received line to cache
    - data_array[index] ← received_line
    - tag_array[index] ← tag
    - valid_array[index] ← 1
    - Go to IDLE (retry will hit)

- [ ] **Output signals**
  - ready: (state == IDLE) && hit
  - stall: (state != IDLE) || (req && !hit)
  - data: data_array[index][word_offset] (on hit)

- [ ] **Initialization**
  - Reset: Clear all valid bits
  - Tags and data: don't care (will be written on fill)

#### File: `rtl/core/decode.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, stall, flush
  - Inputs: ifid (IF/ID register), wb_rd, wb_data, wb_enable
  - Outputs: idex (ID/EX register)

- [ ] **Instruction field extraction**
  - Extract opcode, rd, funct3, rs1, rs2, funct7 from instruction word
  - Use bit slicing according to RISC-V instruction formats
  - Reference section 3.2.3 for field locations

- [ ] **Register file instantiation**
  - 32 × 32-bit registers
  - Read ports: rs1 → rd1, rs2 → rd2
  - Write port: wb_rd, wb_data, wb_enable (from writeback stage)
  - x0 hardwired to zero

- [ ] **Control decoder**
  - Decode opcode into control signals
  - Generate: reg_write, mem_read, mem_write, branch, jump, alu_src_a, alu_src_b, wb_src
  - Decode ALU operation based on opcode, funct3, funct7[5]
  - Determine immediate type

- [ ] **Control signal generation**
  - Implement case statement or decode table for each opcode
  - LUI: Set writeback source to upper immediate, enable register write
  - AUIPC: Use PC as ALU input A, immediate as input B, add operation
  - JAL/JALR: Set jump flag, writeback PC+4 to register
  - BRANCH: Set branch flag, no register write
  - LOAD: Enable memory read, ALU computes address, writeback from memory
  - STORE: Enable memory write, ALU computes address, no register write
  - IMM operations: Use immediate as ALU input B, decode ALU op from funct3
  - REG operations: Use RS2 as ALU input B, decode ALU op from funct3 and funct7[5]

- [ ] **Immediate generator**
  - Implement mux to select immediate type based on instruction format
  - I-type: Sign-extend 12-bit immediate from bits [31:20]
  - S-type: Concatenate split immediate fields [31:25] and [11:7], sign-extend
  - B-type: Reassemble immediate with bit [0]=0, sign-extend (13-bit result)
  - U-type: Place 20-bit immediate in upper bits, zero lower 12 bits
  - J-type: Reassemble immediate with bit [0]=0, sign-extend (21-bit result)
  - Reference section 3.2.3 for bit layouts

- [ ] **ID/EX pipeline register**
  - Clock enable: !stall
  - Clear on flush or invalid ifid
  - Registered signals:
    - idex.pc ← ifid.pc
    - idex.rs1_data ← rd1
    - idex.rs2_data ← rd2
    - idex.imm ← immediate
    - idex.rs1 ← rs1
    - idex.rs2 ← rs2
    - idex.rd ← rd
    - idex.ctrl ← ctrl
    - idex.valid ← ifid.valid && !flush

#### File: `rtl/core/regfile.sv` (Register File)

- [ ] **Module ports**
  - Inputs: clk, rst_n
  - Read ports: rs1[4:0], rs2[4:0] → rd1[31:0], rd2[31:0]
  - Write port: wr_en, wr_addr[4:0], wr_data[31:0]

- [ ] **Register array**
  - reg [31:0] registers [1:31]  (x0 not stored, always 0)

- [ ] **Combinational read**
  - Implement two read ports for rs1 and rs2
  - Always return 0 for x0 regardless of stored value
  - Direct array access for other registers

- [ ] **Synchronous write**
  - Write on clock edge when write enable is active
  - Ignore writes to x0
  - Optional: Initialize all registers to 0 on reset

- [ ] **Internal forwarding (optional optimization)**
  - Check if write address matches read address on same cycle
  - If match: return write data instead of reading array
  - Improves timing by avoiding write-then-read delay

#### File: `rtl/core/execute.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, stall, flush
  - Inputs: idex (ID/EX register)
  - Inputs: forward_a[1:0], forward_b[1:0] (from hazard unit)
  - Inputs: exmem.alu_result, memwb.result (for forwarding)
  - Outputs: exmem (EX/MEM register), branch_taken, branch_target

- [ ] **Forwarding muxes**
  - Implement 3-to-1 mux for RS1: select from ID/EX, EX/MEM, or MEM/WB
  - Implement 3-to-1 mux for RS2: select from ID/EX, EX/MEM, or MEM/WB
  - Use forward control signals from hazard unit (2 bits each)
  - EX/MEM forwarding takes priority over MEM/WB

- [ ] **ALU input selection**
  - ALU input A mux: select between forwarded RS1 data or PC
  - ALU input B mux: select between forwarded RS2 data or immediate
  - Controlled by alu_src_a and alu_src_b signals from control unit

- [ ] **ALU operation**
  - Implement case statement for all ALU operations
  - Arithmetic: ADD, SUB (use + and - operators)
  - Logical: AND, OR, XOR (bitwise operators)
  - Shifts: SLL, SRL, SRA (use shift amount from lower 5 bits of input B)
  - Comparisons: SLT (signed), SLTU (unsigned) - return 1 if A < B, else 0
  - Pass-through: operations to pass input A or B unchanged

- [ ] **Branch condition evaluation**
  - Decode funct3 to determine branch type
  - BEQ/BNE: Test equality/inequality
  - BLT/BGE: Signed less-than/greater-equal comparison
  - BLTU/BGEU: Unsigned less-than/greater-equal comparison
  - Use forwarded operands (not ID/EX register values)

- [ ] **Branch/Jump target calculation**
  - Branch target: PC + immediate (PC-relative)
  - JAL target: PC + immediate
  - JALR target: (RS1 + immediate) with LSB cleared
  - All targets computed in parallel, selected by control signals

- [ ] **Branch/Jump taken logic**
  - Combine branch condition with branch flag
  - Jump instructions always taken when valid
  - Output: branch_taken signal and target address
  - Used by fetch stage to redirect PC

- [ ] **EX/MEM pipeline register**
  - Clock enable: !stall
  - Clear on flush
  - Registered signals:
    - exmem.alu_result ← alu_result
    - exmem.store_data ← forwarded_b (for stores)
    - exmem.rd ← idex.rd
    - exmem.reg_write ← idex.ctrl.reg_write
    - exmem.mem_read ← idex.ctrl.mem_read
    - exmem.mem_write ← idex.ctrl.mem_write
    - exmem.wb_src ← idex.ctrl.wb_src
    - exmem.funct3 ← idex.ctrl.funct3
    - exmem.valid ← idex.valid && !flush

#### File: `rtl/core/memory.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, stall, flush
  - Inputs: exmem (EX/MEM register)
  - Outputs: memwb (MEM/WB register), dcache_stall
  - Cache interface: dcache_req, dcache_we, dcache_addr, dcache_wdata, dcache_rdata, dcache_ready

- [ ] **D-Cache instantiation**
  - Connect: address ← exmem.alu_result
  - Connect: req ← (exmem.mem_read || exmem.mem_write) && exmem.valid
  - Connect: we ← exmem.mem_write
  - Connect: wdata ← store_data (with byte enables)
  - Receive: rdata, ready, stall

- [ ] **Store data formatting**
  - Generate byte enable signals based on funct3 (SB, SH, SW)
  - SB: Enable single byte based on address[1:0]
  - SH: Enable 2 bytes based on address[1]
  - SW: Enable all 4 bytes
  - Replicate data to all byte positions for partial writes

- [ ] **Load data formatting**
  - Extract correct bytes based on address alignment
  - LB: Load byte, sign-extend to 32 bits
  - LH: Load halfword, sign-extend to 32 bits
  - LW: Load full word
  - LBU: Load byte, zero-extend to 32 bits
  - LHU: Load halfword, zero-extend to 32 bits
  - Use address[1:0] to select which bytes to extract

- [ ] **MEM/WB pipeline register**
  - Clock enable: !stall && !dcache_stall
  - Clear on flush
  - Registered signals:
    - memwb.alu_result ← exmem.alu_result
    - memwb.mem_data ← formatted_rdata
    - memwb.rd ← exmem.rd
    - memwb.reg_write ← exmem.reg_write
    - memwb.wb_src ← exmem.wb_src
    - memwb.valid ← exmem.valid && !flush

- [ ] **Stall generation**
  - dcache_stall ← !dcache_ready && (exmem.mem_read || exmem.mem_write)

#### File: `rtl/core/dcache.sv` (Data Cache)

- [ ] **Module ports**
  - Inputs: clk, rst_n, req, we, addr[31:0], wdata[31:0], byte_enable[3:0]
  - Outputs: rdata[31:0], ready, stall
  - Memory controller interface: mem_req, mem_we, mem_addr, mem_wdata, mem_rdata, mem_ready

- [ ] **Address breakdown**
  - Same as I-Cache: tag[17:0], index[7:0], offset[5:0], word_offset[3:0]

- [ ] **Cache storage arrays**
  - valid_array: reg [255:0]
  - dirty_array: reg [255:0] (for write-back)
  - tag_array: reg [17:0] tags [0:255]
  - data_array: reg [31:0] data [0:255][0:15]

- [ ] **Cache lookup logic (combinational)**
  - Extract index, tag, word_offset
  - Check: hit = valid && (tag == stored_tag)

- [ ] **Write operation (write-back policy)**
  - On write hit:
    - Update data_array[index][word_offset] with wdata (respecting byte_enable)
    - Set dirty_array[index] ← 1
    - ready ← 1
  - On write miss (write-allocate):
    - Fetch line from memory first
    - Then perform write as above

- [ ] **Read operation**
  - On read hit:
    - rdata ← data_array[index][word_offset]
    - ready ← 1
  - On read miss:
    - Check if evicted line is dirty
    - If dirty: Write back to memory first
    - Fetch new line from memory
    - Return requested word

- [ ] **Cache miss FSM**
  - States: IDLE, WRITEBACK_REQ, WRITEBACK_WAIT, FETCH_REQ, FETCH_WAIT, FETCH_FILL
  - IDLE: Handle hits immediately
    - On miss: Check dirty bit
      - If dirty: Go to WRITEBACK_REQ
      - Else: Go to FETCH_REQ
  - WRITEBACK_REQ: Write back dirty line
    - mem_req ← 1, mem_we ← 1
    - mem_addr ← {stored_tag, index, 6'b0}
    - mem_wdata ← entire cache line (burst)
    - Go to WRITEBACK_WAIT
  - WRITEBACK_WAIT: Wait for write completion
    - If mem_ready: Go to FETCH_REQ
  - FETCH_REQ: Request new line from memory
    - mem_req ← 1, mem_we ← 0
    - mem_addr ← {tag, index, 6'b0}
    - Go to FETCH_WAIT
  - FETCH_WAIT: Wait for data
    - If mem_ready: Receive line, go to FETCH_FILL
  - FETCH_FILL: Update cache
    - data_array[index] ← fetched_line
    - tag_array[index] ← tag
    - valid_array[index] ← 1
    - dirty_array[index] ← 0 (or 1 if this was a write miss)
    - Go to IDLE

- [ ] **Byte enable handling**
  - For sub-word writes, update only enabled bytes
  - SW (word write): All 4 byte_enable bits set
  - SH (halfword): 2 bits set based on address alignment
  - SB (byte): 1 bit set based on address alignment
  - Update individual bytes in data array word based on byte_enable mask

- [ ] **Output signals**
  - ready: (state == IDLE) && hit
  - stall: (state != IDLE) || (req && !hit)
  - rdata: data_array[index][word_offset]

#### File: `rtl/core/writeback.sv`

- [ ] **Module ports**
  - Inputs: memwb (MEM/WB register)
  - Outputs: wb_rd[4:0], wb_data[31:0], wb_enable

- [ ] **Result multiplexer**
  - Select writeback data source based on wb_src control signal
  - Sources: ALU result, memory data, PC+4, upper immediate
  - 4-to-1 mux implementation

- [ ] **Writeback outputs**
  - Output destination register address
  - Output selected writeback data
  - Enable signal: only write if reg_write is set, instruction is valid, and rd != x0

#### File: `rtl/core/hazard_unit.sv`

- [ ] **Module ports**
  - Inputs: idex, exmem, memwb (pipeline registers)
  - Inputs: dcache_stall, icache_stall
  - Outputs: stall_if, stall_id, stall_ex, stall_mem
  - Outputs: flush_ifid, flush_idex
  - Outputs: forward_a[1:0], forward_b[1:0]

- [ ] **Data forwarding logic**
  - Check if EX/MEM stage is writing to a register that EX stage needs
  - Check if MEM/WB stage is writing to a register that EX stage needs
  - Priority: EX/MEM forwarding overrides MEM/WB forwarding (more recent data)
  - Generate 2-bit forward control signals for both RS1 and RS2
  - Forward control: 00=no forward, 01=from MEM/WB, 10=from EX/MEM
  - Only forward if destination register is not x0

- [ ] **Load-use hazard detection**
  - Detect when ID/EX stage has a load instruction
  - Check if load destination matches IF/ID stage's source registers
  - Must insert 1-cycle stall to allow load data to become available
  - Set load_use_hazard flag when detected

- [ ] **Stall signal generation**
  - Stall IF and ID stages on load-use hazard
  - Stall all stages on cache miss (I-Cache or D-Cache)
  - Generate stall signals for each pipeline stage
  - On load-use: insert bubble (NOP) in EX stage

- [ ] **Branch flush logic**
  - Flush IF/ID and ID/EX stages when branch is taken
  - Clear valid bits to convert instructions to NOPs
  - Prevents incorrect instructions from affecting state

#### File: `rtl/core/mem_controller.sv` (Memory Controller)

- [ ] **Module ports**
  - Inputs: clk, rst_n
  - I-Cache interface: icache_req, icache_addr, icache_data, icache_ready
  - D-Cache interface: dcache_req, dcache_we, dcache_addr, dcache_wdata, dcache_rdata, dcache_ready
  - Main memory interface: 1 MB SRAM or BRAM

- [ ] **Arbitration logic**
  - Priority: D-Cache > I-Cache (data requests more critical)
  - Simple priority arbiter to select which cache gets access
  - Only one cache serviced at a time

- [ ] **Burst transfer handling**
  - Cache line = 64 bytes = 16 words
  - Memory interface: 32-bit wide
  - Implement burst read: Transfer 16 consecutive words
  - Implement burst write: Transfer 16 consecutive words (for dirty evictions)
  - Use address counter to sequence through line

- [ ] **Memory access FSM**
  - States: IDLE, ICACHE_READ, DCACHE_READ, DCACHE_WRITE
  - IDLE: Wait for cache request, arbitrate between caches
  - ICACHE_READ: Burst read 16 words, assert icache_ready when done
  - DCACHE_READ: Burst read 16 words for D-Cache
  - DCACHE_WRITE: Burst write 16 words (write-back dirty line)
  - Increment address by 4 for each word in burst

- [ ] **Memory instantiation**
  - 1 MB memory array (256K 32-bit words)
  - Option: Initialize from hex file using $readmemh
  - Synchronous read and write operations

- [ ] **Access latency modeling**
  - Optional: Add configurable delay to model DRAM latency
  - Typical: 10 cycles per memory access
  - Burst: ~10 cycles initial latency + 1 cycle per word

#### File: `rtl/core/riscv_core.sv` (Top-level Integration)

- [ ] **Module ports**
  - Inputs: clk, rst_n
  - Memory interface (to external controller or internal memory)
  - Optional: Debug interface, interrupt inputs

- [ ] **Pipeline stage instantiation**
  ```systemverilog
  fetch    u_fetch    (.clk, .rst_n, ...);
  decode   u_decode   (.clk, .rst_n, ...);
  execute  u_execute  (.clk, .rst_n, ...);
  memory   u_memory   (.clk, .rst_n, ...);
  writeback u_writeback (.clk, .rst_n, ...);
  ```

- [ ] **Pipeline register instantiation**
  - ifid_t    ifid_reg;
  - idex_t    idex_reg;
  - exmem_t   exmem_reg;
  - memwb_t   memwb_reg;

- [ ] **Cache instantiation**
  ```systemverilog
  icache u_icache (
    .clk, .rst_n,
    .req,  .addr,  .data,  .ready,
    .mem_req, .mem_addr, .mem_data, .mem_ready
  );
  
  dcache u_dcache (
    .clk, .rst_n,
    .req, .we, .addr, .wdata, .byte_enable,
    .rdata, .ready,
    .mem_req, .mem_we, .mem_addr, .mem_wdata, .mem_rdata, .mem_ready
  );
  ```

- [ ] **Memory controller instantiation**
  ```systemverilog
  mem_controller u_mem_controller (
    .clk, .rst_n,
    .icache_req,  .icache_addr,  .icache_data,  .icache_ready,
    .dcache_req,  .dcache_we,    .dcache_addr,  
    .dcache_wdata, .dcache_rdata, .dcache_ready
  );
  ```

- [ ] **Hazard unit instantiation**
  ```systemverilog
  hazard_unit u_hazard_unit (
    .idex, .exmem, .memwb,
    .dcache_stall, .icache_stall,
    .stall_if, .stall_id, .stall_ex, .stall_mem,
    .flush_ifid, .flush_idex,
    .forward_a, .forward_b
  );
  ```

- [ ] **Inter-stage connections**
  - Connect all pipeline registers to their respective stages
  - Connect forwarding paths from hazard_unit to execute
  - Connect stall/flush signals to all stages
  - Connect branch_taken and branch_target from execute to fetch

- [ ] **Clock and reset distribution**
  - Ensure all modules receive clk and rst_n
  - Synchronous reset on all registers

### 3.4.7 Memory System

```
MEMORY MAP (1 MB Total)
=======================

┌────────────────────────────────────────────────┐
│ 0x00000000 - 0x0000FFFF: Boot ROM (64 KB)      │
│   - Initialized from bootrom.hex               │
│   - Contains initialization and bootloader     │
│   - Read-only region                           │
├────────────────────────────────────────────────┤
│ 0x00010000 - 0x0007FFFF: Program (448 KB)      │
│   - Executable code section                    │
│   - Loaded by bootloader or pre-initialized    │
│   - Can be written by cache (data region)      │
├────────────────────────────────────────────────┤
│ 0x00080000 - 0x000FFFFF: Data RAM (512 KB)     │
│   - Heap, stack, global data                   │
│   - Fully read-write                           │
│   - Cacheable                                  │
├────────────────────────────────────────────────┤
│ 0xF0000000 - 0xF00000FF: MMIO (256 B)          │
│   - Memory-mapped peripherals                  │
│   - UART, GPIO, timers, etc.                   │
│   - Non-cacheable (future enhancement)         │
└────────────────────────────────────────────────┘

Cache Access Patterns:
- Sequential reads/writes: Burst transfers fill entire cache line
- Spatial locality: Adjacent addresses share cache line (64 bytes)
- Temporal locality: Recently accessed lines stay in cache

Performance Characteristics:
- Cache hit: 1 cycle
- Cache miss (clean): ~20 cycles (fetch from memory)
- Cache miss (dirty): ~40 cycles (write-back + fetch)
- Branch misprediction: 2 cycles
- Load-use hazard: 1 cycle stall
```

#### File: `rtl/core/memory_model.sv` (Main Memory Module)

- [ ] **Module ports**
  - Inputs: clk, rst_n
  - Read port: rd_addr[31:0], rd_en → rd_data[31:0], rd_valid
  - Write port: wr_addr[31:0], wr_en, wr_data[31:0], wr_strobe[3:0]
  - Burst support: burst_req, burst_addr, burst_len → burst_data[], burst_ready

- [ ] **Memory array**
  - 1 MB = 256K words (32-bit each)
  - Address bits [19:2] select word (bits [1:0] are byte offset)
  - Declare as large array in SystemVerilog

- [ ] **Initialization**
  - Use $readmemh to load boot ROM (addresses 0x0000-0xFFFF)
  - Optionally load program code and data
  - Conditional compilation for different memory images

- [ ] **Read operation**
  - Synchronous read: output data on clock edge
  - Word-aligned access using addr[19:2]
  - Assert rd_valid one cycle after rd_en

- [ ] **Write operation**
  - Synchronous write on clock edge
  - Byte-wise write using write strobe (4 bits, one per byte)
  - Each strobe bit enables write to corresponding byte

- [ ] **Burst read operation** (for cache line fills)
  - Accept burst request with base address
  - Return 16 consecutive words
  - Use counter to sequence through addresses
  - Assert burst_ready when all 16 words transferred
  - Line-align base address (clear lower 6 bits)

- [ ] **Access latency modeling** (optional)
  - Add programmable delay counter
  - Model realistic DRAM latency (~10 cycles)
  - Delay assertion of valid/ready signals

### 3.4.8 Testbench & Verification

This section provides comprehensive testing for the RISC-V core with caches. Tests are organized by complexity: unit tests for individual components, integration tests for pipeline stages, and system tests for complete programs.

#### File: `sim/core/conftest.py` (Common test fixtures)

- [ ] **Pytest/Cocotb fixtures**
  - Create common setup fixture for all tests
  - Initialize clock (e.g., 100 MHz, 10ns period)
  - Start clock with cocotb.start_soon()
  - Implement reset sequence: assert rst_n low, wait, deassert
  - Wait for one clock edge after reset
  - Return configured DUT for tests to use

#### File: `sim/core/test_unit.py` (Unit tests for individual modules)

- [ ] **Test: ALU operations**
  - Test each ALU operation independently
  - Corner cases: overflow, zero, negative numbers

- [ ] **Test: Register file**
  - x0 hardwired to zero
  - Simultaneous read/write to same register

- [ ] **Test: Immediate generator**
  - All immediate types (I, S, B, U, J)
  - Sign extension correctness

- [ ] **Test: Instruction decoder**
  - All opcodes decoded correctly
  - Control signals generated properly

#### File: `sim/core/test_cache.py` (Cache-specific tests)

- [ ] **Test: I-Cache cold miss**
- [ ] **Test: I-Cache hit on repeated access**
- [ ] **Test: D-Cache write-hit (dirty bit set)**
- [ ] **Test: D-Cache write-back on eviction**
- [ ] **Test: Cache line alignment**

#### File: `sim/core/test_integration.py` (Full core tests)

- [ ] **Test: Basic instruction execution** (as detailed above)
- [ ] **Test: Load-store operations**
- [ ] **Test: Branch and jump instructions**
- [ ] **Test: Hazard detection and forwarding**
- [ ] **Test: Pipeline flushes**
- [ ] **Test: Comprehensive programs (Fibonacci, etc.)**

---

## 3.5 Project 3: Boot ROM

**Estimated Lines:** ~40 Assembly

### 3.5.1 Boot ROM Purpose

```
BOOT SEQUENCE
=============

1. CPU comes out of reset, PC = 0x00000000 (Boot ROM)
2. Boot ROM initializes stack pointer
3. Boot ROM waits for data on UART
4. Receives program size (4 bytes)
5. Receives program bytes
6. Writes program to RAM
7. Jumps to RAM start address

┌─────────────────────────────────────────────────────────┐
│                      Boot ROM                           │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │  _start:                                        │    │
│  │      li sp, 0x10010000   # Stack in data RAM    │    │
│  │      call uart_init                             │    │
│  │      call receive_program                       │    │
│  │      li t0, 0x10000000   # Jump to loaded prog  │    │
│  │      jr t0                                      │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  Protocol:                                              │
│    Host sends: [SIZE:4 bytes LE] [DATA: SIZE bytes]     │
│    Device receives into RAM starting at 0x10000000      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3.5.2 Implementation Checklist

#### File: `sw/bootrom/bootrom.s`

- [ ] **Entry point (_start)**
  - Set stack pointer
  - Call initialization

- [ ] **uart_init**
  - Configure UART control register (if needed)
  - Enable RX

- [ ] **uart_getchar**
  - Poll status register for rx_valid
  - Read RXDATA register
  - Return byte in a0

- [ ] **receive_word**
  - Call uart_getchar 4 times
  - Assemble into 32-bit word (little-endian)
  - Return in a0

- [ ] **receive_program**
  - Call receive_word for size
  - Loop: call uart_getchar, store to RAM
  - Decrement counter, repeat until done

- [ ] **Constants**
  - UART base address
  - RAM base address
  - Status register offsets

#### File: `sw/bootrom/Makefile`

- [ ] **Assemble with our assembler**
  - Or use riscv-gnu-toolchain for validation

- [ ] **Generate hex file for FPGA**
  - Format compatible with $readmemh

- [ ] **Generate binary for testing**

#### File: `sim/test_bootrom.py`

- [ ] **Test: boot_and_receive**
  - Load bootrom in instruction memory
  - Simulate UART RX with test program
  - Verify program appears in RAM
  - Verify CPU jumps to RAM

---

## 3.6 Integration Test: CPU + UART + Bootrom

### 3.6.1 System Block Diagram

```
INITIAL SOC
===========

┌───────────────────────────────────────────────────────────────────┐
│                          SOC                                      │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                     Memory Map                              │  │
│  │  0x00000000: Boot ROM (4KB)                                 │  │
│  │  0x10000000: RAM (64KB)                                     │  │
│  │  0x20000000: UART                                           │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌───────────────┐      ┌───────────────────────────────────┐     │
│  │   RISC-V      │      │         Bus Interconnect          │     │
│  │    Core       │◀────▶│  (simple address decode mux)      │     │
│  └───────────────┘      └───────────────────────────────────┘     │
│                                │           │           │          │
│                                ▼           ▼           ▼          │
│                         ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│                         │Boot ROM │  │   RAM   │  │  UART   │     │
│                         └─────────┘  └─────────┘  └─────────┘     │
│                                                        │          │
│                                                        ▼          │
│                                                   TX ──────────▶  │
│                                                   RX ◀──────────  │
└───────────────────────────────────────────────────────────────────┘
```

#### File: `rtl/soc/soc.sv`

- [ ] **Module ports**
  - clk, rst_n
  - UART TX/RX
  - Optional: LEDs, other I/O

- [ ] **Core instantiation**
  - RISC-V core

- [ ] **Memory instantiation**
  - Boot ROM with bootrom.hex
  - RAM

- [ ] **Peripheral instantiation**
  - UART

- [ ] **Bus interconnect**
  - Address decode (combinational)
  - Read data mux
  - Write routing

---

## 3.7 Key Implementation Features

### 3.7.1 Classic 5-Stage Pipeline

The processor implements a textbook 5-stage pipeline with clear stage boundaries:
- **Fetch (IF)**: Instruction fetch from memory, PC increment/branch redirection
- **Decode (ID)**: Instruction decode, register reads, immediate generation
- **Execute (EX)**: ALU operations, branch condition evaluation, address calculation
- **Memory (MEM)**: Load/store operations to data memory
- **Writeback (WB)**: Register file write-back

Each stage completes one instruction per cycle (under ideal conditions).

### 3.7.2 Forwarding (Data Bypassing)

Eliminates unnecessary stalls for data dependencies:
- **EX-EX forwarding**: ALU result from EX/MEM stage fed directly to ALU inputs
  - Typical case: `ADD x1, x2, x3` followed by `ADD x4, x1, x5` → 0 stalls
- **MEM-EX forwarding**: ALU result from MEM/WB stage fed to ALU inputs  
  - Covers cases where previous instruction's result now in WB

**Forwarding mux logic in EX stage:**
```
For rs1 input:
  - If EX/MEM.rd == ID/EX.rs1 and EX/MEM.RegWrite: use EX/MEM.result
  - Else if MEM/WB.rd == ID/EX.rs1 and MEM/WB.RegWrite: use MEM/WB.result
  - Else: use original ID/EX.rs1_data

Similar for rs2 (critical for store data forwarding).
```

Exception: Load-use dependencies still require 1-cycle stall (load data unavailable until MEM stage).

### 3.7.3 Load-Use Hazard Detection

Identifies and stalls on load-use dependencies:
- Detect in hazard unit: `ID/EX.MemRead AND (ID/EX.rd == IF/ID.rs1 OR IF/ID.rs2)`
- Action: Insert 1-cycle stall bubble
- Example:
  ```
  LW  x1, 0(x2)      # Load x1
  ADD x3, x1, x4     # Stall: x1 not ready until MEM stage
  ```
  After stall, result from MEM stage is forwarded to EX.

### 3.7.4 Basic Branch Prediction (Predict-Not-Taken)

Simple static prediction that assumes branches are not taken:
- **Prediction in IF**: Always fetch next instruction as PC+4
- **Validation in EX**: Compute actual branch target and condition
- **Misprediction penalty**: 2-cycle flush
  - Flush IF/ID and ID/EX pipeline stages on misprediction
  - Redirect PC to correct branch target
  - 2 wasted cycles per misprediction

**Performance trade-off**: Simple hardware, but penalty on all taken branches. Can be upgraded to:
- **2-bit saturating counter**: Track recent branch outcomes
- **Branch Target Buffer (BTB)**: Cache common branch targets
- **Return address stack**: Predict function returns

Current version prioritizes simplicity suitable for learning.

---

## 3.8 Concepts to Internalize

Before proceeding to Section 4:

1. **Pipeline timing**: Understand when each stage reads/writes
2. **Hazards are fundamental**: Any pipeline faces these issues
3. **Forwarding vs stalling tradeoffs**: Performance vs complexity
4. **Branch prediction**: Simple predict-not-taken is baseline, can improve with history
5. **Memory-mapped I/O**: Peripherals look like memory addresses
6. **Boot sequence**: How systems initialize from nothing

---

## 3.9 Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| Register x0 written | Check for rd == 0, don't write |
| Wrong immediate sign extension | Carefully follow RISC-V spec |
| Branch offset calculation | Relative to current PC, not PC+4 |
| Forwarding logic incomplete | Must handle rs2 for stores AND both rs1/rs2 for ALU |
| Store uses wrong rs2 value | Always forward rs2 path separately from rs1 |
| JAL/JALR link register | Must write PC+4, not branch target |
| Bypassing not synchronizing | Forward from EX/MEM and MEM/WB, not from WB that's retired |
| Branch prediction too aggressive | Predict-not-taken simpler than 2-bit counter; test both |
| Not invalidating on flush | Must clear valid bit on branch misprediction |
| Stall logic inverts incorrectly | Double-check stall vs enable logic in pipeline registers |
