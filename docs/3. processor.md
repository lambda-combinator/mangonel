# Section 3: Processor — What is a Processor Anyway?

**Duration:** 3 weeks  
**Prerequisites:** Section 2 (UART working)  
**Hardware Language:** SystemVerilog  
**Software Languages:** Python (assembler), Assembly (bootrom)

---

## 3.1 Overview

This section builds a complete RISC-V processor:

1. **RISC-V Assembler** (Python, ~500 lines) — Translates assembly to machine code
2. **5-Stage RISC-V CPU** (SystemVerilog, ~1500 lines) — Classic pipelined processor
3. **Boot ROM** (Assembly, ~40 lines) — Initial code to load programs via UART

We implement RV32I — the base 32-bit integer instruction set. No floating point, no compressed instructions, no multiplication (yet).

---

## 3.2 RISC-V ISA Overview

### 3.2.1 Design Philosophy

RISC-V is:
- **Open**: Free to implement, no licensing fees
- **Simple**: Small base ISA, optional extensions
- **Regular**: Consistent instruction encoding
- **Modern**: Learned from 40 years of RISC experience

### 3.2.2 Registers

```
RISC-V INTEGER REGISTERS (RV32I)
================================

Register │ ABI Name │ Description           │ Saver
─────────┼──────────┼───────────────────────┼────────
x0       │ zero     │ Hard-wired zero       │ N/A
x1       │ ra       │ Return address        │ Caller
x2       │ sp       │ Stack pointer         │ Callee
x3       │ gp       │ Global pointer        │ --
x4       │ tp       │ Thread pointer        │ --
x5-x7    │ t0-t2    │ Temporaries           │ Caller
x8       │ s0/fp    │ Saved reg/Frame ptr   │ Callee
x9       │ s1       │ Saved register        │ Callee
x10-x11  │ a0-a1    │ Args / Return values  │ Caller
x12-x17  │ a2-a7    │ Arguments             │ Caller
x18-x27  │ s2-s11   │ Saved registers       │ Callee
x28-x31  │ t3-t6    │ Temporaries           │ Caller

Special:
- PC: Program Counter (not directly accessible)
- x0 always reads as 0, writes are discarded
```

### 3.2.3 Instruction Formats

```
RISC-V BASE INSTRUCTION FORMATS
===============================

All instructions are 32 bits, naturally aligned.

R-type (Register-Register):
┌─────────┬───────┬───────┬──────┬───────┬─────────┐
│  funct7 │  rs2  │  rs1  │funct3│  rd   │ opcode  │
│  [31:25]│[24:20]│[19:15]│[14:12]│[11:7]│  [6:0]  │
│  7 bits │5 bits │5 bits │3 bits│5 bits │ 7 bits  │
└─────────┴───────┴───────┴──────┴───────┴─────────┘
Example: ADD rd, rs1, rs2

I-type (Immediate):
┌─────────────────┬───────┬──────┬───────┬─────────┐
│    imm[11:0]    │  rs1  │funct3│  rd   │ opcode  │
│    [31:20]      │[19:15]│[14:12]│[11:7]│  [6:0]  │
│    12 bits      │5 bits │3 bits│5 bits │ 7 bits  │
└─────────────────┴───────┴──────┴───────┴─────────┘
Example: ADDI rd, rs1, imm; LW rd, offset(rs1)

S-type (Store):
┌─────────┬───────┬───────┬──────┬─────────┬─────────┐
│imm[11:5]│  rs2  │  rs1  │funct3│imm[4:0] │ opcode  │
│ [31:25] │[24:20]│[19:15]│[14:12]│ [11:7] │  [6:0]  │
│ 7 bits  │5 bits │5 bits │3 bits│ 5 bits  │ 7 bits  │
└─────────┴───────┴───────┴──────┴─────────┴─────────┘
Example: SW rs2, offset(rs1)

B-type (Branch):
┌────┬────────┬───────┬───────┬──────┬────────┬────┬─────────┐
│[12]│[10:5]  │  rs2  │  rs1  │funct3│ [4:1]  │[11]│ opcode  │
│ 1  │ 6 bits │5 bits │5 bits │3 bits│ 4 bits │ 1  │ 7 bits  │
└────┴────────┴───────┴───────┴──────┴────────┴────┴─────────┘
Example: BEQ rs1, rs2, offset (PC-relative, 13-bit signed, ×2)

U-type (Upper Immediate):
┌─────────────────────────┬───────┬─────────┐
│       imm[31:12]        │  rd   │ opcode  │
│        20 bits          │5 bits │ 7 bits  │
└─────────────────────────┴───────┴─────────┘
Example: LUI rd, imm; AUIPC rd, imm

J-type (Jump):
┌────┬──────────┬────┬──────────┬───────┬─────────┐
│[20]│ [10:1]   │[11]│ [19:12]  │  rd   │ opcode  │
│ 1  │ 10 bits  │ 1  │  8 bits  │5 bits │ 7 bits  │
└────┴──────────┴────┴──────────┴───────┴─────────┘
Example: JAL rd, offset (PC-relative, 21-bit signed, ×2)
```

### 3.2.4 RV32I Instruction List

```
RV32I BASE INSTRUCTIONS
=======================

ARITHMETIC:
  ADD   rd, rs1, rs2    # rd = rs1 + rs2
  SUB   rd, rs1, rs2    # rd = rs1 - rs2
  ADDI  rd, rs1, imm    # rd = rs1 + sext(imm)

LOGICAL:
  AND   rd, rs1, rs2    # rd = rs1 & rs2
  OR    rd, rs1, rs2    # rd = rs1 | rs2
  XOR   rd, rs1, rs2    # rd = rs1 ^ rs2
  ANDI  rd, rs1, imm    # rd = rs1 & sext(imm)
  ORI   rd, rs1, imm    # rd = rs1 | sext(imm)
  XORI  rd, rs1, imm    # rd = rs1 ^ sext(imm)

SHIFTS:
  SLL   rd, rs1, rs2    # rd = rs1 << rs2[4:0]
  SRL   rd, rs1, rs2    # rd = rs1 >> rs2[4:0] (logical)
  SRA   rd, rs1, rs2    # rd = rs1 >> rs2[4:0] (arithmetic)
  SLLI  rd, rs1, shamt  # rd = rs1 << shamt
  SRLI  rd, rs1, shamt  # rd = rs1 >> shamt (logical)
  SRAI  rd, rs1, shamt  # rd = rs1 >> shamt (arithmetic)

COMPARE:
  SLT   rd, rs1, rs2    # rd = (rs1 < rs2) ? 1 : 0 (signed)
  SLTU  rd, rs1, rs2    # rd = (rs1 < rs2) ? 1 : 0 (unsigned)
  SLTI  rd, rs1, imm    # rd = (rs1 < sext(imm)) ? 1 : 0
  SLTIU rd, rs1, imm    # rd = (rs1 < sext(imm)) ? 1 : 0 (unsigned cmp)

LOAD/STORE:
  LW    rd, off(rs1)    # rd = mem[rs1 + sext(off)]
  LH    rd, off(rs1)    # rd = sext(mem[rs1 + off][15:0])
  LHU   rd, off(rs1)    # rd = zext(mem[rs1 + off][15:0])
  LB    rd, off(rs1)    # rd = sext(mem[rs1 + off][7:0])
  LBU   rd, off(rs1)    # rd = zext(mem[rs1 + off][7:0])
  SW    rs2, off(rs1)   # mem[rs1 + sext(off)] = rs2
  SH    rs2, off(rs1)   # mem[rs1 + off][15:0] = rs2[15:0]
  SB    rs2, off(rs1)   # mem[rs1 + off][7:0] = rs2[7:0]

BRANCH:
  BEQ   rs1, rs2, off   # if (rs1 == rs2) PC += sext(off)
  BNE   rs1, rs2, off   # if (rs1 != rs2) PC += sext(off)
  BLT   rs1, rs2, off   # if (rs1 < rs2) PC += off (signed)
  BGE   rs1, rs2, off   # if (rs1 >= rs2) PC += off (signed)
  BLTU  rs1, rs2, off   # if (rs1 < rs2) PC += off (unsigned)
  BGEU  rs1, rs2, off   # if (rs1 >= rs2) PC += off (unsigned)

JUMP:
  JAL   rd, offset      # rd = PC+4; PC += sext(offset)
  JALR  rd, off(rs1)    # rd = PC+4; PC = (rs1 + sext(off)) & ~1

UPPER IMMEDIATE:
  LUI   rd, imm         # rd = imm << 12
  AUIPC rd, imm         # rd = PC + (imm << 12)

SYSTEM:
  ECALL                 # Environment call (syscall)
  EBREAK                # Debugger breakpoint
```

---

## 3.3 Project 1: RISC-V Assembler

**Estimated Lines:** ~500 Python

### 3.3.1 Assembler Architecture

```
ASSEMBLER PIPELINE
==================

┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   Source     │    │    Lexer     │    │   Parser     │    │   Encoder    │
│   .s file    │───▶│              │───▶│              │───▶│              │
│              │    │  Tokenize    │    │  Parse AST   │    │ Gen machine  │
│              │    │              │    │              │    │    code      │
└──────────────┘    └──────────────┘    └──────────────┘    └──────────────┘
                                                                   │
                                               ┌───────────────────┘
                                               ▼
                    ┌──────────────┐    ┌──────────────┐
                    │   Output     │◀───│   Linker     │
                    │  .bin/.elf   │    │  (Phase 2)   │
                    │              │    │              │
                    └──────────────┘    └──────────────┘

Pass 1: Collect labels, compute addresses
Pass 2: Resolve labels, encode instructions
```

### 3.3.2 Implementation Checklist

#### File: `tools/assembler/riscv_asm.py` (Main)

- [ ] **Command-line interface**
  - Input file argument
  - Output file argument
  - Output format flag (binary, hex, elf)
  - Base address option

- [ ] **Main assemble() function**
  - Read source file
  - Call lexer
  - Call parser (pass 1)
  - Call encoder (pass 2)
  - Write output

#### File: `tools/assembler/lexer.py`

- [ ] **Token class/namedtuple**
  - Fields: type, value, line_num, column

- [ ] **Token types enum**
  - INSTRUCTION, REGISTER, IMMEDIATE, LABEL, LABEL_REF
  - DIRECTIVE, STRING, COMMA, LPAREN, RPAREN, COLON, NEWLINE, EOF

- [ ] **Lexer class**
  - Input: source string
  - Output: list of tokens

- [ ] **tokenize() method**
  - Skip whitespace and comments (# to end of line)
  - Recognize instruction mnemonics
  - Recognize register names (x0-x31 and ABI names)
  - Recognize immediates (decimal, hex 0x, binary 0b)
  - Recognize labels (identifier followed by colon)
  - Recognize label references (identifier)
  - Recognize directives (.text, .data, .word, .byte, .ascii, .align)
  - Handle string literals

- [ ] **Error reporting**
  - Line number and column
  - Helpful error message

#### File: `tools/assembler/parser.py`

- [ ] **AST node classes**
  - Instruction: mnemonic, operands, address
  - Label: name, address
  - Directive: name, arguments
  - DataWord/DataByte: value, address

- [ ] **Parser class**
  - Input: token list
  - Output: AST + symbol table

- [ ] **First pass: collect_labels()**
  - Iterate through tokens
  - Track current address
  - Record label addresses in symbol table
  - Handle alignment directives

- [ ] **parse_instruction()**
  - Match instruction mnemonic
  - Parse operands based on instruction format
  - Return Instruction AST node

- [ ] **parse_operand()**
  - Register: return register number (0-31)
  - Immediate: return integer value
  - Label reference: return label name (resolved later)
  - Memory operand: parse offset(reg) syntax

- [ ] **parse_directive()**
  - .text: switch to text section
  - .data: switch to data section
  - .word: emit 32-bit value
  - .half: emit 16-bit value
  - .byte: emit 8-bit value
  - .ascii/.asciz: emit string bytes
  - .align: align address
  - .global: mark symbol as global
  - .equ: define constant

#### File: `tools/assembler/encoder.py`

- [ ] **Encoder class**
  - Input: AST, symbol table
  - Output: byte array

- [ ] **Instruction encoding tables**
  - Opcode for each instruction
  - funct3 for each instruction
  - funct7 where applicable
  - Instruction format (R, I, S, B, U, J)

- [ ] **encode_r_type()**
  - Pack: funct7, rs2, rs1, funct3, rd, opcode
  - Return 4-byte little-endian

- [ ] **encode_i_type()**
  - Pack: imm[11:0], rs1, funct3, rd, opcode
  - Sign extend immediate if negative

- [ ] **encode_s_type()**
  - Split immediate: imm[11:5], imm[4:0]
  - Pack appropriately

- [ ] **encode_b_type()**
  - Calculate PC-relative offset
  - Check offset fits in 13 bits (signed, ×2)
  - Scramble immediate bits per B-format

- [ ] **encode_u_type()**
  - Pack: imm[31:12], rd, opcode

- [ ] **encode_j_type()**
  - Calculate PC-relative offset
  - Check offset fits in 21 bits (signed, ×2)
  - Scramble immediate bits per J-format

- [ ] **Pseudo-instruction expansion**
  - `li rd, imm` → LUI + ADDI (if imm > 12 bits)
  - `la rd, label` → AUIPC + ADDI
  - `mv rd, rs` → ADDI rd, rs, 0
  - `nop` → ADDI x0, x0, 0
  - `j offset` → JAL x0, offset
  - `jr rs` → JALR x0, rs, 0
  - `ret` → JALR x0, ra, 0
  - `call label` → AUIPC + JALR
  - `tail label` → AUIPC + JALR (without link)
  - `beqz rs, off` → BEQ rs, x0, off
  - `bnez rs, off` → BNE rs, x0, off

- [ ] **Label resolution**
  - Look up label in symbol table
  - Calculate offset relative to current PC
  - Error if label undefined

#### File: `tools/assembler/output.py`

- [ ] **write_binary()**
  - Raw bytes, starting at base address
  - Pad with zeros if gaps in address space

- [ ] **write_hex()**
  - Intel HEX or simple hex dump
  - For loading into simulation memory

- [ ] **write_verilog_mem()**
  - `$readmemh` compatible format
  - Address: data pairs

#### File: `tools/assembler/test_assembler.py`

- [ ] **Test: arithmetic_instructions**
  - Assemble ADD, SUB, ADDI
  - Verify encoding matches reference

- [ ] **Test: logical_instructions**
  - AND, OR, XOR, ANDI, ORI, XORI

- [ ] **Test: shift_instructions**
  - SLL, SRL, SRA, SLLI, SRLI, SRAI

- [ ] **Test: load_store_instructions**
  - LW, SW, LH, LB, LHU, LBU, SH, SB

- [ ] **Test: branch_instructions**
  - BEQ, BNE, BLT, BGE, BLTU, BGEU
  - Forward and backward branches
  - Verify offsets

- [ ] **Test: jump_instructions**
  - JAL, JALR with various offsets

- [ ] **Test: upper_immediate**
  - LUI, AUIPC

- [ ] **Test: pseudo_instructions**
  - li, la, mv, nop, j, ret, call

- [ ] **Test: labels**
  - Forward reference
  - Backward reference
  - Label arithmetic

- [ ] **Test: directives**
  - .word, .byte, .align, .ascii

- [ ] **Test: error_handling**
  - Undefined label
  - Invalid register
  - Offset out of range
  - Syntax errors

---

## 3.4 Project 2: 5-Stage RISC-V CPU

**Estimated Lines:** ~1500 SystemVerilog

### 3.4.1 Classic 5-Stage Pipeline

```
5-STAGE RISC-V PIPELINE WITH FORWARDING & BRANCH PREDICTION
============================================================

┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│  FETCH  │──▶│ DECODE  │──▶│ EXECUTE │──▶│ MEMORY  │──▶│WRITEBACK│
│   (IF)  │   │  (ID)   │   │  (EX)   │   │  (MEM)  │   │  (WB)   │
└─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘
     ▲             │             │             │             │
     │             ▼             ▼             ▼             ▼
     │        ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
     │        │  IF/ID  │   │  ID/EX  │   │ EX/MEM  │   │ MEM/WB  │
     │        │   Reg   │   │   Reg   │   │   Reg   │   │   Reg   │
     │        └─────────┘   └─────────┘   └─────────┘   └─────────┘
     │             │             │             │             │
     └─────────────┴─────────────┴─────────────┴─────────────┘
              (Forwarding paths, branch prediction)

Stage Functions:
- IF:  Fetch instruction from memory, predict branches, increment PC
- ID:  Decode instruction, read registers, extend immediate
- EX:  ALU operation, branch resolution, address calculation, forwarding muxes
- MEM: Load/store memory access
- WB:  Write result back to register file

Enhancements:
- Forwarding: Bypass ALU results to dependent instructions
- Load-use stall: Insert bubble on load-dependent operation
- Branch prediction: Simple predict-not-taken, flush on misprediction
- Branch resolution: In EX stage (2-cycle flush penalty)
```

### 3.4.2 Datapath Block Diagram with Forwarding

```
DETAILED DATAPATH WITH FORWARDING & PREDICTION
===============================================

                    ┌──────────────────────────────────────────────────────────┐
                    │          HAZARD & CONTROL UNIT                           │
                    │   (stall, flush, forward, branch prediction)             │
                    └──────────────────────────────────────────────────────────┘
                         │          │           │           │          │
                         ▼          ▼           ▼           ▼          ▼

┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│  ┌────────────┐    ┌────────────┐    ┌────────────┐    ┌────────────┐    ┌──────────┐ │
│  │   FETCH    │    │   DECODE   │    │  EXECUTE   │    │   MEMORY   │    │ WRITEBACK│ │
│  │    (IF)    │    │    (ID)    │    │    (EX)    │    │   (MEM)    │    │   (WB)   │ │
│  └────────────┘    └────────────┘    └────────────┘    └────────────┘    └──────────┘ │
│         │                │                  │                 │                │      │
│         ▼                ▼                  ▼                 ▼                ▼      │
│    ┌────────┐       ┌────────┐        ┌────────┐        ┌────────┐      ┌────────┐  │
│    │ IF/ID  │       │ ID/EX  │        │ EX/MEM │        │ MEM/WB │      │ Result │  │
│    │  Reg   │───────│  Reg   │────────│  Reg   │────────│  Reg   │      │ Mux    │  │
│    └────────┘       └────────┘        └────────┘        └────────┘      └────────┘  │
│         │                │                  │                 │                │      │
│         │            ┌───┴───┐              │                 │                │      │
│         │            ▼       ▼              │                 │                │      │
│         │        ┌────────┐ ┌────────┐      │                 │                │      │
│         │        │Decoder │ │ RegFile│      │                 │                │      │
│         │        └────────┘ │        │      │                 │                │      │
│         │            │       │        │      │                 │                │      │
│         │            ▼       └───┬────┘      │                 │                │      │
│         │        ┌────────┐      │           │                 │                │      │
│         │        │Imm Gen │      │           │                 │                │      │
│         │        └────────┘      │           │                 │                │      │
│         │            │           ▼           │                 │                │      │
│         │            │       ┌────────┐      │                 │                │      │
│         └────────────┴──────▶│Forward │      │                 │                │      │
│                              │  Muxes │      │                 │                │      │
│                              └────┬───┘      │                 │                │      │
│                                   │          ▼                 │                │      │
│                              ┌────▼───┐  ┌────────┐            │                │      │
│                              │  ALU   │  │ Branch │            │                │      │
│                              │        │  │Compare │            │                │      │
│                              └───┬────┘  └────┬───┘            │                │      │
│                                  │            │                │                │      │
│                                  │            ▼                │                │      │
│                                  │       ┌──────────┐          │                │      │
│                                  │       │ Branch   │          │                │      │
│                                  │       │ Target & │          │                │      │
│                                  │       │ Taken    │          │                │      │
│                                  │       └──────┬───┘          │                │      │
│                                  ▼              ▼               ▼                ▼      ▼
│                            ┌────────────────────────────────────────────────────────┐  │
│                            │          Forwarding Paths (EX/MEM & MEM/WB)           │  │
│                            └────────────────────────────────────────────────────────┘  │
│                                                                                         │
│  ┌──────────────────────────────────────────────────────────────────────────────────┐ │
│  │                         Data Memory & Load Processing                            │ │
│  │                                                                                  │ │
│  │   ┌──────────────────────────────────────────────────────────────────────┐     │ │
│  │   │  Address from ALU ──▶ [ Memory ] ──▶ Load (LW/LH/LB) ──▶ Result Mux │     │ │
│  │   │  Store Data from RS2 ──▶                                             │     │ │
│  │   └──────────────────────────────────────────────────────────────────────┘     │ │
│  └──────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘

PC & Branch Prediction (in Fetch stage):
  - PC register: current program counter
  - Branch Prediction Unit: predict next PC (simple: PC+4 predict-not-taken)
  - Branch misprediction detected in EX stage, flushes pipeline, corrects PC
  
Key Forwarding Paths:
  - EX/MEM.result ──▶ ALU inputs (highest priority, most recent result)
  - MEM/WB.result ──▶ ALU inputs (lower priority, for older results)
```

### 3.4.3 Pipeline Hazards & Solutions

```
DATA HAZARDS, LOAD-USE HAZARDS, AND CONTROL HAZARDS
===================================================

1. DATA HAZARDS (RAW - Read After Write)
────────────────────────────────────────

Problem: Instruction needs data not yet written back

  ADD x1, x2, x3    [IF][ID][EX][MEM][WB]
  SUB x4, x1, x5       [IF][ID][EX][MEM][WB]   ← needs x1 from ADD
                            ↑
                        x1 not ready yet!

Solution A: STALLING (insert bubbles)
  ADD x1, x2, x3    [IF][ID][EX][MEM][WB]
  SUB x4, x1, x5       [IF][ID][──][──][EX][MEM][WB]   ← 2 stall cycles
                            (stall) (stall)

Solution B: FORWARDING (ALU-to-ALU bypass)
  ADD x1, x2, x3    [IF][ID][EX][MEM][WB]
  SUB x4, x1, x5       [IF][ID][EX][MEM][WB]   ← forward from EX result
                            ↑─────────┘
                     (NO stall, data bypassed)

Forwarding logic:
  - Forward from EX/MEM if result being computed matches rs1 or rs2
  - Forward from MEM/WB if result in writeback matches rs1 or rs2
  - EX/MEM takes priority (most recent)


2. LOAD-USE HAZARD (special case of RAW)
─────────────────────────────────────────

Problem: Load followed immediately by use—data from memory not ready in EX

  LW  x1, 0(x2)     [IF][ID][EX][MEM][WB]
  ADD x3, x1, x4       [IF][ID][EX][MEM][WB]   ← needs x1
                            ↑
                    Data available here (MEM stage)
                    But ADD needs it in EX (earlier!)

Cannot bypass memory data (too late), must stall:

  LW  x1, 0(x2)     [IF][ID][EX][MEM][WB]
  ADD x3, x1, x4       [IF][ID][──][EX][MEM][WB]   ← 1 stall, forward MEM result
                            (stall)

Solution: Load-use hazard detection
  - Detect: if ID/EX.mem_read AND (ID/EX.rd == IF/ID.rs1 OR IF/ID.rs2)
  - Insert 1 stall bubble in EX stage
  - Forward from MEM/WB on next cycle


3. CONTROL HAZARDS (branches and jumps)
───────────────────────────────────────

Problem: Don't know next instruction PC until branch condition resolved

  BEQ x1, x2, label [IF][ID][EX][MEM][WB]
  instr2              [IF][ID][??][??][??]   ← wrong instr if branch taken?
  instr3                 [IF][??][??][??][??]

Our approach: Branch in EX stage with prediction

Solution A: Predict NOT TAKEN (simple, static)
  - Assume branch not taken, fetch PC+4
  - If branch actually taken: flush 2 instructions (IF/ID, ID/EX)
  - Cost: 2-cycle flush penalty on misprediction

  Predict not taken:
    ┌─────────┬─────────┬─────────┬─────────┬─────────┐
    │BEQ      │fetch PC+4 fetch PC+4 │ TAKEN!  │ Flush   │
    │[IF][ID] │[EX]     │[ID]     │[MEM]   │[flush] │
    └─────────┴─────────┴─────────┴─────────┴─────────┘
    
    Correct path taken:
    ┌─────────┬──────────┬──────────┬─────────┬─────────┐
    │BEQ      │fetch PC+4│fetch PC+4│correct │correct │
    │[IF][ID] │[EX]      │[ID]      │[MEM]   │[WB]    │
    └─────────┴──────────┴──────────┴─────────┴─────────┘

- Stall all: Wait until branch resolved in EX (simple but slow)
- Predict with table: 2-bit predictor, more complex


FORWARDING PATHS
================

From EX/MEM to EX inputs (ALU operands):
  if (EX/MEM.RegWrite && EX/MEM.Rd != 0 && EX/MEM.Rd == ID/EX.Rs1)
    forward EX/MEM.ALU_result to ALU input A

  if (EX/MEM.RegWrite && EX/MEM.Rd != 0 && EX/MEM.Rd == ID/EX.Rs2)
    forward EX/MEM.ALU_result to ALU input B

From MEM/WB to EX inputs (lower priority):
  if (MEM/WB.RegWrite && MEM/WB.Rd != 0 && MEM/WB.Rd == ID/EX.Rs1)
    AND NOT (EX/MEM.RegWrite && EX/MEM.Rd != 0 && EX/MEM.Rd == ID/EX.Rs1)
    forward MEM/WB.Result to ALU input A

Similarly for Rs2.

Note: Rs2 also needs forwarding for store data (SW, SH, SB)
```

### 3.4.4 Implementation Checklist

#### File: `rtl/core/pkg_riscv.sv` (Package)

- [ ] **Opcode definitions**
  ```systemverilog
  typedef enum logic [6:0] {
      OP_LUI    = 7'b0110111,
      OP_AUIPC  = 7'b0010111,
      OP_JAL    = 7'b1101111,
      OP_JALR   = 7'b1100111,
      OP_BRANCH = 7'b1100011,
      OP_LOAD   = 7'b0000011,
      OP_STORE  = 7'b0100011,
      OP_IMM    = 7'b0010011,
      OP_REG    = 7'b0110011,
      OP_SYSTEM = 7'b1110011
  } opcode_t;
  ```

- [ ] **ALU operation codes**
  - ADD, SUB, AND, OR, XOR, SLT, SLTU, SLL, SRL, SRA

- [ ] **Immediate type enum**
  - I_TYPE, S_TYPE, B_TYPE, U_TYPE, J_TYPE

- [ ] **Control signal struct**
  - reg_write, mem_read, mem_write, branch, alu_src, etc.

#### File: `rtl/core/fetch.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, stall, flush, pred_pc (from branch prediction)
  - Outputs: pc, instruction, valid

- [ ] **PC register**
  - Reset to configurable start address (e.g., 0x00000000)
  - Increment by 4 each cycle (unless stall/flush)

- [ ] **PC mux**
  - Normal: PC + 4
  - Flush (branch misprediction): Corrected PC from EX stage
  - Stall: hold current PC

- [ ] **Instruction memory interface**
  - Address = PC
  - Read enable
  - Instruction output

- [ ] **IF/ID pipeline register**
  - PC value (for branch offset calculation)
  - Instruction word
  - Valid bit (cleared on flush)
  - Prediction state (for validation in EX)

#### File: `rtl/core/decode.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, stall, flush, instruction, pc
  - Inputs: wb_rd, wb_data, wb_enable (writeback)
  - Outputs: all decoded signals, register values

- [ ] **Instruction field extraction**
  - opcode = instr[6:0]
  - rd = instr[11:7]
  - funct3 = instr[14:12]
  - rs1 = instr[19:15]
  - rs2 = instr[24:20]
  - funct7 = instr[31:25]

- [ ] **Register file**
  - 32 x 32-bit registers
  - x0 hardwired to zero
  - 2 read ports, 1 write port
  - Write on falling edge or separate write stage

- [ ] **Immediate generator**
  - I-type: sign-extend instr[31:20]
  - S-type: sign-extend {instr[31:25], instr[11:7]}
  - B-type: sign-extend {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}
  - U-type: {instr[31:12], 12'b0}
  - J-type: sign-extend {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0}

- [ ] **Control decoder**
  - Generate all control signals based on opcode/funct3/funct7
  - Output: alu_op, alu_src, mem_read, mem_write, reg_write, branch, jump

- [ ] **ID/EX pipeline register**
  - Control signals
  - rs1_data, rs2_data
  - Immediate value
  - rd address
  - PC value
  - rs1, rs2 addresses (for hazard detection)

#### File: `rtl/core/execute.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, all decoded values, forward_ctrl (from hazard unit)
  - Outputs: alu_result, branch_target, branch_taken, branch_mispredicted

- [ ] **Forwarding control muxes** (with 3-to-1 mux)
  - Source for rs1: {from MEM/WB, from EX/MEM, from ID/EX}, select by forward_ctrl[1:0]
  - Source for rs2: {from MEM/WB, from EX/MEM, from ID/EX}, select by forward_ctrl[3:2]
  
  Forwarding priority (EX/MEM > MEM/WB):
  ```
  forward_ctrl[1:0]:
    00 = no forward (use ID/EX.rs1_data)
    01 = forward from EX/MEM.alu_result
    10 = forward from MEM/WB.result
    11 = (undefined)
  ```

- [ ] **ALU input muxes**
  - A input: forwarded_rs1 (or PC+immediate for AUIPC/branch offset)
  - B input: forwarded_rs2 (or immediate for I-type)

- [ ] **ALU (32-bit operations)**
  - ADD: A + B
  - SUB: A - B
  - AND, OR, XOR: bitwise
  - SLT: (A <_signed B) ? 1 : 0
  - SLTU: (A <_unsigned B) ? 1 : 0
  - SLL: A << B[4:0]
  - SRL: A >> B[4:0] (logical)
  - SRA: A >> B[4:0] (arithmetic, sign-extend)

- [ ] **Branch condition evaluation** (uses forwarded operands)
  - BEQ: forwarded_rs1 == forwarded_rs2
  - BNE: forwarded_rs1 != forwarded_rs2
  - BLT: signed(forwarded_rs1) < signed(forwarded_rs2)
  - BGE: signed(forwarded_rs1) >= signed(forwarded_rs2)
  - BLTU: unsigned(forwarded_rs1) < unsigned(forwarded_rs2)
  - BGEU: unsigned(forwarded_rs1) >= unsigned(forwarded_rs2)

- [ ] **Branch target calculation**
  - For branch: actual_target = PC + imm_B
  - For JAL: actual_target = PC + imm_J
  - For JALR: actual_target = (forwarded_rs1 + imm_I) & ~1

- [ ] **Branch prediction validation**
  - Compare actual_target with predicted_target from IF
  - If mispredicted: set branch_mispredicted flag
  - Return actual_target for PC correction in IF

- [ ] **EX/MEM pipeline register**
  - ALU result
  - forwarded_rs2 (for store data)
  - Control signals (mem_read, mem_write, reg_write)
  - rd address
  - Branch misprediction flag + corrected PC

#### File: `rtl/core/memory.sv`

- [ ] **Module ports**
  - Inputs: clk, rst_n, alu_result, write_data, control signals
  - Outputs: read_data, passthrough signals

- [ ] **Memory interface**
  - Address from ALU result
  - Write data from rs2
  - Byte enables based on funct3 (byte/half/word)
  - Read enable for loads

- [ ] **Load data processing**
  - LW: full word
  - LH: sign-extend halfword
  - LHU: zero-extend halfword
  - LB: sign-extend byte
  - LBU: zero-extend byte

- [ ] **MEM/WB pipeline register**
  - Memory read data
  - ALU result
  - Control signals
  - rd address

#### File: `rtl/core/writeback.sv`

- [ ] **Result mux**
  - Select between memory data and ALU result
  - Based on mem_to_reg control signal

- [ ] **Writeback outputs**
  - rd address
  - Write data
  - Write enable

#### File: `rtl/core/hazard_unit.sv`

- [ ] **Load-use hazard detection**
  - Detect: ID/EX.mem_read AND (ID/EX.rd == IF/ID.rs1 OR ID/EX.rd == IF/ID.rs2)
  - Action: Stall IF and ID, insert NOP (bubble) in EX
  - Effect: 1-cycle stall, then forwarding from MEM/WB resolves

- [ ] **Data forwarding control signal generation** (for execute.sv inputs)
  
  ```systemverilog
  // Forward to rs1:
  if (EX/MEM.reg_write && EX/MEM.rd != 0 && EX/MEM.rd == ID/EX.rs1)
    forward_rs1 = 2'b01;  // from EX/MEM
  else if (MEM/WB.reg_write && MEM/WB.rd != 0 && MEM/WB.rd == ID/EX.rs1)
    forward_rs1 = 2'b10;  // from MEM/WB
  else
    forward_rs1 = 2'b00;  // no forward (use ID/EX.rs1_data)
  
  // Same logic for rs2
  if (EX/MEM.reg_write && EX/MEM.rd != 0 && EX/MEM.rd == ID/EX.rs2)
    forward_rs2 = 2'b01;  // from EX/MEM
  else if (MEM/WB.reg_write && MEM/WB.rd != 0 && MEM/WB.rd == ID/EX.rs2)
    forward_rs2 = 2'b10;  // from MEM/WB
  else
    forward_rs2 = 2'b00;  // no forward
  ```

- [ ] **Branch prediction validation** (simple predict-not-taken)
  - Always predict next PC = PC + 4 in IF
  - In EX: check if branch is actually taken
  - If (branch_taken AND actual_target != predicted_PC+4): misprediction
  - If mispredicted: flush IF/ID and ID/EX, redirect PC

- [ ] **Flush signal generation**
  - On branch misprediction: flush <= 1
  - Clears valid bits in IF/ID and ID/EX (insert NOPs)
  - Takes 2 cycles to recover

- [ ] **Stall signal generation**
  - For load-use: stall <= (load_use_hazard)
  - Stalls IF and ID, inserts NOP in EX

- [ ] **Control signal outputs**
  - stall_IF, stall_ID: hold PC, freeze pipeline registers
  - flush_IFID, flush_IDEX: clear valid bits (turn into NOPs)
  - forward_rs1[1:0], forward_rs2[1:0]: select muxes in EX

#### File: `rtl/core/branch_pred.sv` (Branch Prediction Unit)

- [ ] **Module ports**
  - Inputs: clk, pc, branch_actual_target, branch_mispredicted
  - Outputs: pred_target (predicted next PC)

- [ ] **Simple predict-not-taken predictor**
  - Default prediction: next_pc = pc + 4
  - No state or tables (simplest version)
  
  Optional 2-bit saturating counter for future extension:
  ```
  State machine:
    00 (strongly not taken)  ──mispred on taken──> 10 (weakly taken)
    01 (weakly not taken)    ──mispred on taken──> 10 (weakly taken)
    10 (weakly taken)        ──mispred on not────> 01 (weakly not taken)
    11 (strongly taken)      ──mispred on not────> 01 (weakly not taken)
  ```

- [ ] **Output: predicted_pc**
  - Combinational: always pc_next = pc + 4 (for predict-not-taken)
  - Or conditional based on 2-bit counter if implemented

#### File: `rtl/core/riscv_core.sv` (Top-level)

- [ ] **Module ports**
  - Inputs: clk, rst_n
  - Instruction memory interface
  - Data memory interface

- [ ] **Stage instantiation**
  - Instantiate all 5 stages: fetch, decode, execute, memory, writeback
  - Instantiate hazard_unit
  - Instantiate branch_pred (optional, can be in fetch.sv)

- [ ] **Pipeline register instantiation**
  - IF/ID register
  - ID/EX register (with forwarding sources)
  - EX/MEM register
  - MEM/WB register

- [ ] **Glue logic**
  - Connect forwarding paths from hazard_unit to execute.sv muxes
  - Connect stall/flush signals from hazard_unit to all stages
  - Connect branch_mispredicted flag to IF PC mux
  - Connect actual branch target to IF for correction

#### File: `rtl/core/regfile.sv` (Separate module)

- [ ] **32 registers, 32-bit each**
  - x0 always returns 0
  - 2 combinational read ports
  - 1 synchronous write port

- [ ] **Bypass for same-cycle read/write**
  - If reading register being written, return new value

### 3.4.5 Memory Interface

```
MEMORY INTERFACE
================

For simulation, use simple synchronous BRAM:

┌─────────────────────────────────────────────────────┐
│                  Memory System                       │
│                                                     │
│  Instruction Memory          Data Memory            │
│  ┌─────────────────┐        ┌─────────────────┐    │
│  │  Single Port    │        │  Single Port    │    │
│  │  Read Only      │        │  Read/Write     │    │
│  │                 │        │                 │    │
│  │  4KB - 64KB     │        │  4KB - 64KB     │    │
│  │  (configurable) │        │  (configurable) │    │
│  └─────────────────┘        └─────────────────┘    │
│         │                          │               │
│         │    ┌──────────────┐     │               │
│         └───▶│  RISC-V Core │◀────┘               │
│              └──────────────┘                      │
└─────────────────────────────────────────────────────┘

Memory Map (Initial):
  0x00000000 - 0x0000FFFF: Instruction Memory (ROM/BRAM)
  0x10000000 - 0x1000FFFF: Data Memory (BRAM)
  0x20000000 - 0x200000FF: UART (MMIO)
```

#### File: `rtl/core/imem.sv`

- [ ] **Single-port ROM**
  - Parameterized size (depth, width)
  - Initialize from file ($readmemh)
  - Synchronous read

#### File: `rtl/core/dmem.sv`

- [ ] **Single-port RAM**
  - Parameterized size
  - Byte-enable for sub-word writes
  - Synchronous read and write

### 3.4.6 Testbench Checklist

#### File: `tb/test_riscv_core.py`

- [ ] **Helper: load_program()**
  - Load hex file into instruction memory
  - Use cocotb memory access

- [ ] **Helper: read_register()**
  - Access register file through hierarchy
  - Useful for checking results

- [ ] **Test: nop_execution**
  - Load NOPs
  - Verify PC increments
  - Verify no state change

- [ ] **Test: arithmetic_instructions**
  - ADD, SUB, ADDI
  - Verify result in destination register

- [ ] **Test: logical_instructions**
  - AND, OR, XOR, etc.

- [ ] **Test: load_store**
  - SW then LW
  - Verify data integrity
  - Test byte/halfword variants

- [ ] **Test: branches**
  - BEQ taken and not taken
  - BNE, BLT, BGE variants
  - Verify correct PC

- [ ] **Test: jumps**
  - JAL: verify link register and PC
  - JALR: verify computed target

- [ ] **Test: hazard_forwarding**
  - Sequence requiring EX-EX forward
  - Sequence requiring MEM-EX forward

- [ ] **Test: load_use_hazard**
  - LW followed by dependent instruction
  - Verify stall inserted
  - Verify correct result

- [ ] **Test: branch_hazard**
  - Branch followed by instructions
  - Verify flush on taken branch

- [ ] **Test: comprehensive_program**
  - Run a small program (e.g., sum array)
  - Verify final result

#### File: `tb/riscv_compliance/`

- [ ] **RISC-V compliance test integration**
  - Run official RISC-V test suite
  - Automated pass/fail checking

---

## 3.5 Project 3: Boot ROM

**Estimated Lines:** ~40 Assembly

### 3.5.1 Boot ROM Purpose

```
BOOT SEQUENCE
=============

1. CPU comes out of reset, PC = 0x00000000 (Boot ROM)
2. Boot ROM initializes stack pointer
3. Boot ROM waits for data on UART
4. Receives program size (4 bytes)
5. Receives program bytes
6. Writes program to RAM
7. Jumps to RAM start address

┌─────────────────────────────────────────────────────────┐
│                      Boot ROM                            │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │  _start:                                         │   │
│  │      li sp, 0x10010000   # Stack in data RAM    │   │
│  │      call uart_init                              │   │
│  │      call receive_program                        │   │
│  │      li t0, 0x10000000   # Jump to loaded prog  │   │
│  │      jr t0                                       │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
│  Protocol:                                              │
│    Host sends: [SIZE:4 bytes LE] [DATA: SIZE bytes]    │
│    Device receives into RAM starting at 0x10000000     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3.5.2 Implementation Checklist

#### File: `sw/bootrom/bootrom.s`

- [ ] **Entry point (_start)**
  - Set stack pointer
  - Call initialization

- [ ] **uart_init**
  - Configure UART control register (if needed)
  - Enable RX

- [ ] **uart_getchar**
  - Poll status register for rx_valid
  - Read RXDATA register
  - Return byte in a0

- [ ] **receive_word**
  - Call uart_getchar 4 times
  - Assemble into 32-bit word (little-endian)
  - Return in a0

- [ ] **receive_program**
  - Call receive_word for size
  - Loop: call uart_getchar, store to RAM
  - Decrement counter, repeat until done

- [ ] **Constants**
  - UART base address
  - RAM base address
  - Status register offsets

#### File: `sw/bootrom/Makefile`

- [ ] **Assemble with our assembler**
  - Or use riscv-gnu-toolchain for validation

- [ ] **Generate hex file for FPGA**
  - Format compatible with $readmemh

- [ ] **Generate binary for testing**

#### File: `tb/test_bootrom.py`

- [ ] **Test: boot_and_receive**
  - Load bootrom in instruction memory
  - Simulate UART RX with test program
  - Verify program appears in RAM
  - Verify CPU jumps to RAM

---

## 3.6 Integration Test: CPU + UART + Bootrom

### 3.6.1 System Block Diagram

```
INITIAL SOC
===========

┌───────────────────────────────────────────────────────────────────┐
│                          SOC                                       │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                     Memory Map                               │ │
│  │  0x00000000: Boot ROM (4KB)                                 │ │
│  │  0x10000000: RAM (64KB)                                     │ │
│  │  0x20000000: UART                                           │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                   │
│  ┌───────────────┐      ┌───────────────────────────────────┐   │
│  │   RISC-V      │      │         Bus Interconnect          │   │
│  │    Core       │◀────▶│  (simple address decode mux)      │   │
│  └───────────────┘      └───────────────────────────────────┘   │
│                                │           │           │         │
│                                ▼           ▼           ▼         │
│                         ┌─────────┐  ┌─────────┐  ┌─────────┐   │
│                         │Boot ROM │  │   RAM   │  │  UART   │   │
│                         └─────────┘  └─────────┘  └─────────┘   │
│                                                        │         │
│                                                        ▼         │
│                                                   TX ──────────▶ │
│                                                   RX ◀────────── │
└───────────────────────────────────────────────────────────────────┘
```

#### File: `rtl/soc/soc.sv`

- [ ] **Module ports**
  - clk, rst_n
  - UART TX/RX
  - Optional: LEDs, other I/O

- [ ] **Core instantiation**
  - RISC-V core

- [ ] **Memory instantiation**
  - Boot ROM with bootrom.hex
  - RAM

- [ ] **Peripheral instantiation**
  - UART

- [ ] **Bus interconnect**
  - Address decode (combinational)
  - Read data mux
  - Write routing

---

## 3.7 Key Implementation Features

### 3.7.1 Classic 5-Stage Pipeline

The processor implements a textbook 5-stage pipeline with clear stage boundaries:
- **Fetch (IF)**: Instruction fetch from memory, PC increment/branch redirection
- **Decode (ID)**: Instruction decode, register reads, immediate generation
- **Execute (EX)**: ALU operations, branch condition evaluation, address calculation
- **Memory (MEM)**: Load/store operations to data memory
- **Writeback (WB)**: Register file write-back

Each stage completes one instruction per cycle (under ideal conditions).

### 3.7.2 Forwarding (Data Bypassing)

Eliminates unnecessary stalls for data dependencies:
- **EX-EX forwarding**: ALU result from EX/MEM stage fed directly to ALU inputs
  - Typical case: `ADD x1, x2, x3` followed by `ADD x4, x1, x5` → 0 stalls
- **MEM-EX forwarding**: ALU result from MEM/WB stage fed to ALU inputs  
  - Covers cases where previous instruction's result now in WB

**Forwarding mux logic in EX stage:**
```
For rs1 input:
  - If EX/MEM.rd == ID/EX.rs1 and EX/MEM.RegWrite: use EX/MEM.result
  - Else if MEM/WB.rd == ID/EX.rs1 and MEM/WB.RegWrite: use MEM/WB.result
  - Else: use original ID/EX.rs1_data

Similar for rs2 (critical for store data forwarding).
```

Exception: Load-use dependencies still require 1-cycle stall (load data unavailable until MEM stage).

### 3.7.3 Load-Use Hazard Detection

Identifies and stalls on load-use dependencies:
- Detect in hazard unit: `ID/EX.MemRead AND (ID/EX.rd == IF/ID.rs1 OR IF/ID.rs2)`
- Action: Insert 1-cycle stall bubble
- Example:
  ```
  LW  x1, 0(x2)      # Load x1
  ADD x3, x1, x4     # Stall: x1 not ready until MEM stage
  ```
  After stall, result from MEM stage is forwarded to EX.

### 3.7.4 Basic Branch Prediction (Predict-Not-Taken)

Simple static prediction that assumes branches are not taken:
- **Prediction in IF**: Always fetch next instruction as PC+4
- **Validation in EX**: Compute actual branch target and condition
- **Misprediction penalty**: 2-cycle flush
  - Flush IF/ID and ID/EX pipeline stages on misprediction
  - Redirect PC to correct branch target
  - 2 wasted cycles per misprediction

**Performance trade-off**: Simple hardware, but penalty on all taken branches. Can be upgraded to:
- **2-bit saturating counter**: Track recent branch outcomes
- **Branch Target Buffer (BTB)**: Cache common branch targets
- **Return address stack**: Predict function returns

Current version prioritizes simplicity suitable for learning.

---

## 3.8 Concepts to Internalize

Before proceeding to Section 4:

1. **Pipeline timing**: Understand when each stage reads/writes
2. **Hazards are fundamental**: Any pipeline faces these issues
3. **Forwarding vs stalling tradeoffs**: Performance vs complexity
4. **Branch prediction**: Simple predict-not-taken is baseline, can improve with history
5. **Memory-mapped I/O**: Peripherals look like memory addresses
6. **Boot sequence**: How systems initialize from nothing

---

## 3.9 Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| Register x0 written | Check for rd == 0, don't write |
| Wrong immediate sign extension | Carefully follow RISC-V spec |
| Branch offset calculation | Relative to current PC, not PC+4 |
| Forwarding logic incomplete | Must handle rs2 for stores AND both rs1/rs2 for ALU |
| Store uses wrong rs2 value | Always forward rs2 path separately from rs1 |
| JAL/JALR link register | Must write PC+4, not branch target |
| Bypassing not synchronizing | Forward from EX/MEM and MEM/WB, not from WB that's retired |
| Branch prediction too aggressive | Predict-not-taken simpler than 2-bit counter; test both |
| Not invalidating on flush | Must clear valid bit on branch misprediction |
| Stall logic inverts incorrectly | Double-check stall vs enable logic in pipeline registers |
