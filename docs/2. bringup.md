# Section 2: Bringup — What Language is Hardware Coded In?

**Duration:** 0.5 weeks  
**Prerequisites:** Section 1 (Environment Setup)  
**Hardware Language:** SystemVerilog  
**Test Framework:** cocotb (Python)

---

## 2.1 Overview

This section introduces SystemVerilog through two practical projects:
1. **Blinking an LED** — Your first synthesizable design, introducing clocks and counters
2. **Building a UART** — A real communication peripheral, introducing serial protocols and MMIO

By the end, you'll have a working UART that can echo characters and control LEDs—the foundation for all future development and debugging.

---

## 2.2 Project 1: Blinking an LED

**Estimated Lines:** ~50 SystemVerilog, ~50 Python (test)

### 2.2.1 Learning Objectives

- Understand clock-driven sequential logic
- Write your first `always_ff` block
- Create parameterized modules
- Run cocotb simulations
- Generate and view waveforms

### 2.2.2 The Concept

An LED blinker requires:
1. A clock input (e.g., 50 MHz)
2. A counter that increments each clock cycle
3. An LED output that toggles when counter reaches threshold

```
LED BLINKER BLOCK DIAGRAM
=========================

                    ┌─────────────────────────────────────┐
                    │           led_blinker               │
                    │                                     │
   clk    ─────────▶│  ┌─────────────┐    ┌──────────┐    │
   (50MHz)          │  │   Counter   │    │Comparator│    │
                    │  │             │    │          │    │
   rst_n  ─────────▶│  │  count[26:0]│───▶│ count ≥  │───▶│─────▶ led_out
   (active low)     │  │             │    │ THRESHOLD│    │
                    │  └─────────────┘    └──────────┘    │
                    │        ↑                            │
                    │        │ +1 each cycle              │
                    │        │ reset to 0 when rst_n=0    │
                    └─────────────────────────────────────┘

For 1Hz blink at 50MHz clock:
  THRESHOLD = 50,000,000 / 2 = 25,000,000
  (divide by 2 because LED toggles, so full cycle = 2 toggles)
  
Counter width: ceil(log2(25,000,000)) = 25 bits minimum
```

### 2.2.3 SystemVerilog Concepts Introduced

#### Module Declaration
```systemverilog
module led_blinker #(
    parameter int CLK_FREQ = 50_000_000,  // Clock frequency in Hz
    parameter int BLINK_FREQ = 1          // Blink frequency in Hz
) (
    input  logic clk,
    input  logic rst_n,
    output logic led
);
```

#### Localparam Calculations
```systemverilog
localparam int COUNTER_MAX = CLK_FREQ / (2 * BLINK_FREQ) - 1;
localparam int COUNTER_WIDTH = $clog2(COUNTER_MAX + 1);
```

#### Sequential Logic Block
```systemverilog
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        // Asynchronous reset
    end else begin
        // Normal operation
    end
end
```

### 2.2.4 Implementation Checklist

#### File: `rtl/peripherals/led_blinker.sv`

- [ ] **Module declaration**
  - Parameters: `CLK_FREQ`, `BLINK_FREQ`
  - Inputs: `clk`, `rst_n`
  - Outputs: `led`

- [ ] **Local parameter calculation**
  - Calculate `COUNTER_MAX` from frequencies
  - Calculate `COUNTER_WIDTH` using `$clog2`

- [ ] **Counter register declaration**
  - Width: `COUNTER_WIDTH` bits
  - Type: `logic [COUNTER_WIDTH-1:0]`

- [ ] **LED state register declaration**
  - Width: 1 bit
  - Type: `logic`

- [ ] **Counter logic (always_ff block)**
  - Reset condition: set counter to 0
  - Overflow condition: if counter >= COUNTER_MAX, reset to 0
  - Normal: increment counter by 1

- [ ] **LED toggle logic**
  - When counter overflows, toggle LED state
  - Reset condition: LED off (or on, your choice)

- [ ] **Output assignment**
  - Connect LED register to output port

#### File: `tb/test_led_blinker.py`

- [ ] **Import statements**
  - cocotb, cocotb.triggers, cocotb.clock

- [ ] **Clock generation helper**
  - Use `cocotb.clock.Clock` class
  - Fork clock as background task

- [ ] **Reset helper coroutine**
  - Assert reset (low)
  - Wait several clock cycles
  - Deassert reset (high)

- [ ] **Test: reset_behavior**
  - Apply reset
  - Verify LED is in known state
  - Verify counter is 0

- [ ] **Test: led_toggles**
  - Use short COUNTER_MAX for simulation (override parameter)
  - Run for 2+ full blink cycles
  - Count LED transitions
  - Assert correct number of toggles

- [ ] **Test: timing_accuracy**
  - Verify LED toggles at correct cycle count
  - Check exact cycle where toggle occurs

#### File: `tb/Makefile` (cocotb)

- [ ] **TOPLEVEL variable**
  - Set to `led_blinker`

- [ ] **MODULE variable**
  - Set to `test_led_blinker`

- [ ] **VERILOG_SOURCES**
  - Path to led_blinker.sv

- [ ] **Verilator-specific settings**
  - `SIM = verilator`
  - `EXTRA_ARGS` for parameters override

- [ ] **Include cocotb Makefile**
  - `include $(shell cocotb-config --makefiles)/Makefile.sim`

### 2.2.5 Verification Waveform Checklist

After running simulation, verify in GTKWave:
- [ ] Clock toggles at expected rate
- [ ] Reset properly initializes counter to 0
- [ ] Counter increments each clock cycle
- [ ] Counter resets to 0 at COUNTER_MAX
- [ ] LED toggles when counter resets
- [ ] LED maintains state between toggles

---

## 2.3 Project 2: Building a UART

**Estimated Lines:** ~200 SystemVerilog, ~150 Python (test)

### 2.3.1 Learning Objectives

- Understand asynchronous serial communication
- Implement finite state machines in SystemVerilog
- Design memory-mapped I/O (MMIO) interfaces
- Handle clock domain concepts (baud rate generation)
- Create reusable peripheral modules

### 2.3.2 UART Protocol Background

```
UART FRAME FORMAT
=================

Idle ─────┐     ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐     ┌───── Idle
(HIGH)    │     │ D │ D │ D │ D │ D │ D │ D │ D │ S │     │ (HIGH)
          │START│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │TOP│     │
          └─────┴───┴───┴───┴───┴───┴───┴───┴───┴───┴─────┘
          │                                         │
          ◀─────────────── 1 Frame ────────────────▶

- Idle state: Line held HIGH
- Start bit: Line goes LOW for 1 bit period
- Data bits: 8 bits, LSB first
- Stop bit: Line goes HIGH for 1 bit period (or more)

Baud Rate: bits per second (e.g., 115200 baud)
Bit Period = 1 / Baud Rate = 8.68 µs @ 115200 baud

At 50 MHz clock:
  Cycles per bit = 50,000,000 / 115,200 ≈ 434 cycles
```

### 2.3.3 UART Block Diagram

```
UART MODULE ARCHITECTURE
========================

                    ┌─────────────────────────────────────────────────────────┐
                    │                        uart                             │
                    │                                                         │
                    │  ┌────────────────────────────────────────────────────┐ │
                    │  │                  MMIO Interface                    │ │
   Bus Interface    │  │                                                    │ │
   ─────────────────┼─▶│  Address Decode    Register File                   │ │
   addr[7:0]        │  │  ┌──────────┐     ┌─────────────────────┐          │ │
   wdata[7:0]       │  │  │ 0x00: TX │────▶│ tx_data[7:0]        │          │ │
   rdata[7:0]       │  │  │ 0x04: RX │◀────│ rx_data[7:0]        │          │ │
   wen              │  │  │ 0x08:STAT│◀────│ status (tx_rdy,     │          │ │
   ren              │  │  │ 0x0C:CTRL│────▶│         rx_valid)   │          │ │
                    │  │  └──────────┘     └─────────────────────┘          │ │
                    │  └────────────────────────────────────────────────────┘ │
                    │           │                    ▲                        │
                    │           ▼                    │                        │
                    │  ┌────────────────┐   ┌────────────────┐                │
                    │  │   TX Module    │   │   RX Module    │                │
                    │  │                │   │                │                │
                    │  │ ┌────────────┐ │   │ ┌────────────┐ │                │
                    │  │ │ Baud Gen   │ │   │ │ Baud Gen   │ │                │
                    │  │ └────────────┘ │   │ └────────────┘ │                │
                    │  │ ┌────────────┐ │   │ ┌────────────┐ │                │
                    │  │ │ Shift Reg  │ │   │ │ Shift Reg  │ │                │
                    │  │ └────────────┘ │   │ └────────────┘ │                │
                    │  │ ┌────────────┐ │   │ ┌────────────┐ │                │
                    │  │ │    FSM     │ │   │ │    FSM     │ │                │
                    │  │ └────────────┘ │   │ └────────────┘ │                │
                    │  └───────┬────────┘   └───────┬────────┘                │
                    │          │                    │                         │
                    └──────────┼────────────────────┼─────────────────────────┘
                               ▼                    ▲
                             tx_out               rx_in
                           (to pin)            (from pin)


MMIO REGISTER MAP
=================

Offset │ Name   │ R/W │ Description
───────┼────────┼─────┼─────────────────────────────────
0x00   │ TXDATA │  W  │ Write byte to transmit
0x04   │ RXDATA │  R  │ Read received byte (clears rx_valid)
0x08   │ STATUS │  R  │ Bit 0: tx_ready (1=can write)
       │        │     │ Bit 1: rx_valid (1=data available)
0x0C   │ CTRL   │ R/W │ Bit 0: tx_enable
       │        │     │ Bit 1: rx_enable
       │        │     │ Bit 2: loopback mode
```

### 2.3.4 Transmitter State Machine

```
UART TX STATE MACHINE
=====================

                    ┌───────────────┐
                    │               │
         ┌─────────▶│     IDLE      │◀─────────┐
         │          │               │          │
         │          └───────┬───────┘          │
         │                  │                  │
         │                  │ tx_start         │
         │                  │ (write to TXDATA)│
         │                  ▼                  │
         │          ┌───────────────┐          │
         │          │               │          │
         │          │    START      │          │
         │          │   (tx=LOW)    │          │
         │          └───────┬───────┘          │
         │                  │                  │
         │                  │ bit_tick         │
         │                  ▼                  │
         │          ┌───────────────┐          │
         │          │               │          │
         │          │     DATA      │──┐       │
         │          │  (send bits)  │  │       │
         │          └───────┬───────┘  │       │
         │                  │          │       │
         │                  │ bit_tick │       │
         │                  │ & bit<7  │       │
         │                  └──────────┘       │
         │                  │                  │
         │                  │ bit_tick         │
         │                  │ & bit==7         │
         │                  ▼                  │
         │          ┌───────────────┐          │
         │          │               │          │
         │          │     STOP      │          │
         │          │   (tx=HIGH)   │          │
         │          └───────┬───────┘          │
         │                  │                  │
         │                  │ bit_tick         │
         └──────────────────┴──────────────────┘

bit_tick: generated by baud rate divider
```

### 2.3.5 Receiver State Machine

```
UART RX STATE MACHINE
=====================

                    ┌───────────────┐
                    │               │
         ┌─────────▶│     IDLE      │◀─────────┐
         │          │  (wait for    │          │
         │          │   start bit)  │          │
         │          └───────┬───────┘          │
         │                  │                  │
         │                  │ rx_in == LOW     │
         │                  ▼                  │
         │          ┌───────────────┐          │
         │          │               │          │
         │          │  START_CHECK  │──────────┤
         │          │ (sample at    │  rx_in   │
         │          │  mid-bit)     │  == HIGH │
         │          └───────┬───────┘ (glitch) │
         │                  │                  │
         │                  │ half_bit_tick    │
         │                  │ & rx_in == LOW   │
         │                  ▼                  │
         │          ┌───────────────┐          │
         │          │               │          │
         │          │     DATA      │──┐       │
         │          │ (sample bits) │  │       │
         │          └───────┬───────┘  │       │
         │                  │          │       │
         │                  │ bit_tick │       │
         │                  │ & bit<7  │       │
         │                  └──────────┘       │
         │                  │                  │
         │                  │ bit_tick         │
         │                  │ & bit==7         │
         │                  ▼                  │
         │          ┌───────────────┐          │
         │          │               │          │
         │          │     STOP      │          │
         │          │ (verify HIGH) │          │
         │          └───────┬───────┘          │
         │                  │                  │
         │                  │ bit_tick         │
         │                  │ (data valid)     │
         └──────────────────┴──────────────────┘

Key: Sample in middle of each bit for best noise immunity
```

### 2.3.6 Implementation Checklist

#### File: `rtl/peripherals/uart_tx.sv`

- [ ] **Module declaration**
  - Parameters: `CLK_FREQ`, `BAUD_RATE`
  - Inputs: `clk`, `rst_n`, `tx_data[7:0]`, `tx_start`
  - Outputs: `tx_out`, `tx_ready`, `tx_done`

- [ ] **Localparam calculations**
  - `CLKS_PER_BIT = CLK_FREQ / BAUD_RATE`
  - Counter width calculation

- [ ] **State enum declaration**
  - `typedef enum logic [1:0] {IDLE, START, DATA, STOP} state_t;`

- [ ] **Register declarations**
  - State register
  - Bit counter (0-7)
  - Clock counter (baud rate divider)
  - Shift register (8-bit)
  - TX output register

- [ ] **Baud rate tick generation**
  - Counter increments each clock
  - Generates tick when counter reaches CLKS_PER_BIT
  - Counter resets on tick

- [ ] **State machine (always_ff)**
  - IDLE: wait for tx_start, load shift register
  - START: output LOW for one bit period
  - DATA: shift out LSB first, 8 bits total
  - STOP: output HIGH for one bit period

- [ ] **Output logic**
  - `tx_ready = (state == IDLE)`
  - `tx_out` driven by state machine

#### File: `rtl/peripherals/uart_rx.sv`

- [ ] **Module declaration**
  - Parameters: `CLK_FREQ`, `BAUD_RATE`
  - Inputs: `clk`, `rst_n`, `rx_in`
  - Outputs: `rx_data[7:0]`, `rx_valid`

- [ ] **Input synchronizer**
  - 2-FF synchronizer for rx_in (metastability protection)
  - Registered synchronized input

- [ ] **State enum declaration**
  - `typedef enum logic [2:0] {IDLE, START_CHECK, DATA, STOP} state_t;`

- [ ] **Register declarations**
  - State register
  - Bit counter (0-7)
  - Clock counter
  - Shift register (8-bit)
  - rx_data output register
  - rx_valid flag

- [ ] **Mid-bit sampling logic**
  - For START_CHECK: sample at CLKS_PER_BIT/2
  - For DATA/STOP: sample at CLKS_PER_BIT

- [ ] **State machine (always_ff)**
  - IDLE: detect falling edge (start bit)
  - START_CHECK: verify still LOW at mid-bit
  - DATA: sample 8 bits at mid-bit timing
  - STOP: verify HIGH, assert rx_valid

- [ ] **Data capture**
  - Shift in from MSB (so final order is correct)
  - Capture to rx_data on valid stop bit

#### File: `rtl/peripherals/uart.sv` (Top-level)

- [ ] **Module declaration**
  - Parameters: `CLK_FREQ`, `BAUD_RATE`, `ADDR_WIDTH`
  - Bus interface: `addr`, `wdata`, `rdata`, `wen`, `ren`
  - Serial pins: `tx_out`, `rx_in`

- [ ] **Address decode logic**
  - Define register offsets as localparams
  - Combinational address decode

- [ ] **TX data register**
  - Write to TXDATA triggers transmission
  - Capture write data to tx_data register

- [ ] **RX data register**
  - Capture rx module output on rx_valid
  - Clear rx_valid on read

- [ ] **Status register construction**
  - Bit 0: tx_ready
  - Bit 1: rx_valid

- [ ] **Control register**
  - tx_enable, rx_enable, loopback bits
  - Applied to sub-modules

- [ ] **Submodule instantiation**
  - uart_tx instance
  - uart_rx instance

- [ ] **Loopback mux**
  - When loopback enabled: connect tx_out to rx_in internally

#### File: `tb/test_uart_tx.py`

- [ ] **Test: idle_state**
  - Verify tx_out is HIGH when idle
  - Verify tx_ready is HIGH

- [ ] **Test: transmit_byte**
  - Send a known byte (e.g., 0x55 = 01010101)
  - Capture tx_out transitions
  - Verify start bit (LOW)
  - Verify 8 data bits in correct order
  - Verify stop bit (HIGH)
  - Verify timing matches baud rate

- [ ] **Test: transmit_multiple**
  - Send several bytes back-to-back
  - Verify no gaps or glitches
  - Verify tx_ready behavior

- [ ] **Test: transmit_all_patterns**
  - Send 0x00, 0xFF, 0xAA, 0x55
  - Verify bit patterns correct

#### File: `tb/test_uart_rx.py`

- [ ] **Test: idle_state**
  - Drive rx_in HIGH
  - Verify rx_valid is LOW

- [ ] **Test: receive_byte**
  - Generate UART frame on rx_in
  - Use known byte (e.g., 0x55)
  - Verify rx_valid asserts
  - Verify rx_data matches sent byte

- [ ] **Test: receive_multiple**
  - Send several frames
  - Verify each received correctly

- [ ] **Test: glitch_rejection**
  - Send very short LOW pulse (< half bit period)
  - Verify not interpreted as start bit

- [ ] **Test: timing_tolerance**
  - Send frame with ±2% baud rate error
  - Verify still received correctly

- [ ] **Helper: uart_send_byte()**
  - Coroutine to generate UART frame
  - Configurable baud rate
  - Drives rx_in signal

#### File: `tb/test_uart.py` (Integration)

- [ ] **Test: loopback_mode**
  - Enable loopback in control register
  - Write byte to TXDATA
  - Verify same byte appears in RXDATA

- [ ] **Test: mmio_read_write**
  - Write to all writable registers
  - Read back and verify values
  - Read status register

- [ ] **Test: echo_program**
  - Simulate echo behavior
  - Send byte via RX
  - Read from RXDATA via bus
  - Write to TXDATA via bus
  - Verify TX output

### 2.3.7 Semihosting Consideration

For simulation, we may want "semihosting" — a way for the simulated hardware to communicate with the host:

```
SEMIHOSTING ARCHITECTURE
========================

┌──────────────────────────────────────┐
│         cocotb Testbench             │
│                                      │
│  ┌──────────────────────────────┐    │
│  │    Semihost Monitor Task     │    │
│  │                              │    │
│  │  - Watch for magic writes    │    │
│  │  - Print to Python console   │    │
│  │  - Provide stdin input       │    │
│  └──────────────────────────────┘    │
│                ▲                     │
│                │ Monitor             │
│                │ UART TX             │
└────────────────┼─────────────────────┘
                 │
       ┌─────────┴─────────┐
       │   DUT (uart.sv)   │
       └───────────────────┘

Implementation:
- cocotb task monitors tx_out
- Decodes UART frames
- Prints characters to terminal
- Optional: inject characters to rx_in from keyboard
```

---

## 2.4 Putting It Together: Echo Program

### 2.4.1 Test System Block Diagram

```
ECHO TEST SYSTEM
================

┌───────────────────────────────────────────────────────────────┐
│                    echo_system                                │
│                                                               │
│  ┌─────────────┐         ┌─────────────┐                      │
│  │             │  addr   │             │                      │
│  │   Simple    │────────▶│             │                      │
│  │   Tester    │  wdata  │    UART     │─────────▶ tx_out     │
│  │   FSM       │────────▶│             │                      │
│  │             │◀────────│             │◀───────── rx_in      │
│  │             │  rdata  │             │                      │
│  │             │────────▶│             │                      │
│  │             │  wen    │             │                      │
│  │             │────────▶│             │                      │
│  │             │  ren    │             │                      │
│  └─────────────┘         └─────────────┘                      │
│                                                               │
│  Echo FSM: poll RX status, read byte, write to TX             │
│                                                               │
│  Also: LED output directly from RX data register              │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

### 2.4.2 Echo FSM States

```
ECHO FSM
========

      ┌───────────────────────────────────────────────────┐
      │                                                   │
      │  ┌─────────┐                                      │
      └─▶│  IDLE   │◀──────────────────────────┐          │
         │(read    │                           │          │
         │ status) │                           │          │
         └────┬────┘                           │          │
              │                                │          │
              │ status.rx_valid == 1           │          │
              ▼                                │          │
         ┌─────────┐                           │          │
         │READ_RX  │                           │          │
         │(read    │                           │          │
         │ RXDATA) │                           │          │
         └────┬────┘                           │          │
              │                                │          │
              │ captured byte                  │          │
              ▼                                │          │
         ┌─────────┐                           │          │
         │WAIT_TX  │──┐                        │          │
         │(read    │  │ status.tx_ready == 0   │          │
         │ status) │◀─┘                        │          │
         └────┬────┘                           │          │
              │                                │          │
              │ status.tx_ready == 1           │          │
              ▼                                │          │
         ┌─────────┐                           │          │
         │WRITE_TX │                           │          │
         │(write   │───────────────────────────┘          │
         │ TXDATA) │                                      │
         └─────────┘                                      │
```

### 2.4.3 Implementation Checklist for Echo System

#### File: `rtl/soc/echo_system.sv`

- [ ] **Module declaration**
  - Inputs: `clk`, `rst_n`, `rx_in`
  - Outputs: `tx_out`, `led[7:0]`

- [ ] **UART instantiation**
  - Connect all bus signals
  - Connect serial pins

- [ ] **FSM state enum**
  - IDLE, READ_STATUS, READ_RX, WAIT_TX, WRITE_TX

- [ ] **FSM registers**
  - Current state
  - Saved RX byte

- [ ] **Address/data muxing**
  - Based on state, drive correct address
  - Capture read data appropriately

- [ ] **Write enable generation**
  - Only assert in WRITE_TX state

- [ ] **LED connection**
  - Drive LEDs from last received byte

#### File: `tb/test_echo_system.py`

- [ ] **Test: echo_single_char**
  - Send character via rx_in
  - Verify appears on tx_out

- [ ] **Test: echo_string**
  - Send "Hello World"
  - Verify complete echo

- [ ] **Test: led_reflects_data**
  - Send various bytes
  - Verify LED output matches

---

## 2.5 Simulation Commands Quick Reference

```bash
# Run LED blinker tests
cd tb && make TOPLEVEL=led_blinker MODULE=test_led_blinker

# Run UART TX tests
cd tb && make TOPLEVEL=uart_tx MODULE=test_uart_tx

# Run UART RX tests  
cd tb && make TOPLEVEL=uart_rx MODULE=test_uart_rx

# Run full UART tests
cd tb && make TOPLEVEL=uart MODULE=test_uart

# Run echo system tests
cd tb && make TOPLEVEL=echo_system MODULE=test_echo_system

# View waveforms (after simulation)
gtkwave sim_build/dump.fst &
```

---

## 2.6 Concepts to Internalize

Before proceeding to Section 3, ensure you understand:

1. **Synchronous design**: All state changes on clock edge
2. **Reset strategy**: Async vs sync reset, active high vs active low
3. **Metastability**: Why we need synchronizers for external inputs
4. **FSM design**: Moore vs Mealy, state encoding
5. **MMIO concept**: Peripherals accessed via memory addresses
6. **Baud rate**: Relationship between clock frequency and bit timing
7. **Serial protocols**: Start/stop bits, LSB-first transmission

---

## 2.7 Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| Missing synchronizer on rx_in | Always use 2-FF synchronizer |
| Off-by-one in counter | Carefully consider 0-indexed vs 1-indexed |
| Wrong bit order in TX | UART is LSB first |
| Sampling at bit edge vs middle | RX should sample at mid-bit |
| Clock domain confusion | Keep everything in one clock domain for now |
| Blocking vs non-blocking | Use `<=` for sequential, `=` for combinational |